HostMot2 Register map in offsets from 32 bit memory base address
Note the following addresses are standard but driver should use IDROM info
instead of this table as some configurations may not be mapped the same.

Also, number of special functions (counters, PWMGens etc) is determined 
by configuration.
Additional registers are always at increasing doubleword boundaries 
with the exception of UART data FIFOs , SSerial data registers,
BSPI data FIFOs, and ResMod position and velocity registers 


First ID stuff

0x0100	Config cookie 	= 0x55AACAFE
0x0104	First 4 characters of configuration name
0x0108	Last 4 characters of configuration name
0x010C	Offset to IDROM location (normally 0x00000400)

LEDS

0x0200	LEDS are in MS bits (left justified)

Then the IDROM

0x0400	Normal IDROM location

0x400	IDROMType		3 for this type
0x404	OffsetToModules		64 for this type
0x408	OffsetToPindesc		384 for this type
0x40C	BoardNameLow		
0x410	BoardNameHigh
0x414	FPGA size
0x418	FPGA pins
0x41C	IOPorts			
0x420	IOWidth
0x424	PortWidth		
0x428	ClockLow		In Hz	(note:on 5I20/4I65 = PCI clock 
                                guessed as 33.33 MHz)
0x42C	ClockHigh		In Hz
0x430	InstanceStride0		Stride between register instances (option 0)
0x434	InstanceStride1		Stride between register instances (option 1)
0x438	RegisterStride0         Stride between different registers (option 0) 
0x43C	RegisterStride1		Stride between different registers (option 1)

Instance stride is address step to next register of same type but next channel
For example PWMGen(0) to PWMGen(1)
Register stride is address step to next register in functional group. 
for example IOPort(0) to DDR(0)

0x440..	Module descriptions 0 through 31
Each module descriptor is three doublewords with the following record structure:

0x440: (from least to most significant order)
GTag(0		(byte) = General function tag
Version(0)	(byte) = module version
ClockTag(0)	(byte) = Whether module uses ClockHigh or ClockLow
Instances(0)	(byte) = Number of instances of module in configuration
BaseAddress(0)	(word) = offset to module. This is also specific register = Tag
Registers(0)	(byte) = Number of registers per module
Strides(0)	(byte) = Specifies which strides to use
MPBitmap(0)	(Double) = bit map of which registers are multiple 
                '1' = multiple, LSb = reg(0)

0x44C: (from least to most significant order)
GTag(1)		(byte) = General function tag
Version(1)	(byte) = module version
ClockTag(1)	(byte) = Whether module uses ClockHigh or ClockLow
Instances(1)	(byte) = Number of instances of module in configuration
BaseAddress(1)	(word) = offset to module. This is also specific register = Tag
Registers(1)	(byte) = Number of registers per module
Strides(1)	(byte) = Specifies which strides to use
MPBitmap(1)	(Double) = bit map of which registers are multiple 
                '1' = multiple, LSb = reg(0)


0 GTag marks end of module descriptors (note Rev 2 IDROMS MDs start at 0x600)


0x5C0 Pin descriptors 0 through 143. 
There is one Pin Descriptor for each I/O pin.
Each pin descriptor is a doubleword with the following record structure:

0x5C0: (from least to most significant order)
SecPin(0)	(byte) = Which pin of secondary function connects here 
                eg: A,B,IDX. 
                         Output pins have bit 7 = '1'
SecTag(0)	(byte) = Secondary function type (PWM,QCTR etc). 
                Same as module GTag
SecUnit(0)	(byte) = Which secondary unit or channel connects here
PrimaryTag(0)	(byte) = Primary function tag (normally I/O port)

0x5C4:(from least to most significant order)
SecPin(1)	(byte) = Which pin of secondary function connects here 
                eg: A,B,IDX. 
                         Output pins have bit 7 = '1'
SecTag(1)	(byte) = Secondary function type (PWM,QCTR etc). 
                Same as module GTag
SecUnit(1)	(byte) = Which secondary unit or channel connects here
PrimaryTag(1)	(byte) = Primary function tag (normally I/O port)

...



0x0800  1 bit IDROM write enable bit: high=Enable writes


0x0A00	IRQStatus

Bit 2..4  Select which timer is used as IRQ  source:
000 = Timer Reference
001 = Timer1
010 = Timer2
011 = Timer3
100 = Timer4

Bit 1 = Irq mask: 0 = masked

Bit 0 = IRQ status (R/W)

0x0B00	ClearIRQ: Writes here clear IRQ 


0x0C00	WatchdogTimer (R/W

32 bit watchdog timer.If MSb is set, watchdog is disabled.
Timeout is WatchdogTimer+1/CLKLOW. Currently all watchdog does 
is clear GPIO DDR, and OpenDrain registers setting all GPIO to 
inputs (high with pullups)

0x0D00	WatchDogStatus

Bit 0 = Watchdog has bitten status (1 = you been bit)

0x0E00

Watchdog Cookie location

0x5A written to 8 MSbs will reset watchdog to previously written 
timeout value.


Demand mode DMA logic

Bit 0 = Enable Demand mode DMA
Bit 1 = DRQ status, - = active request
Bits 16..31 = DRQ mask for demand mode DMA modules 0..15

Note this should be reset to 0x00000000 to enable re-configuration
on 4I68, 5I23, 5I22, and 3X20 as DREQ/DACK are muxed with /PROGRAM and DONE 
 
0x0F00 = DemandMode DMA enable register
	    

0x1000	I/O port  0..23
0x1004  I/O port 24..47
0x1008  I/O port 48..71
0x100C  I/O port 72..95
0x1010  I/O port 96..127
0x1014  I/O port 128..143

Writes write to output register, reads read pin status

0x1100	DDR for I/O port  0..23
0x1104  DDR for I/O port  24..47
0x1108  DDR for I/O port  48..71
0x110C  DDR for I/O port  72..95
0x1110  DDR for I/O port  96..127
0x1114  DDR for I/O port  128..144

'1' bit in DDR register makes corresponding GPIO bit an output

0x1200  AltSourceReg for I/O port  0..23
0x1204  AltSourceReg for I/O port  24..47
0x1208  AltSourceReg for I/O port  48..71
0x120C  AltSourceReg for I/O port  72..95
0x1210  AltSourceReg for I/O port  96..127
0x1214  AltSourceReg for I/O port  128..143


'1' bit in AltSource register makes corresponding GPIO bit data source 
come from Alternate source for that bit instead of GPIO output register.

0x1300	OpenDrainSelect for I/O port  0..23
0x1304  OpenDrainSelect for I/O port  24..47
0x1308  OpenDrainSelect for I/O port  48..71
0x130C  OpenDrainSelect for I/O port  72..95
0x1310  OpenDrainSelect for I/O port  96..127
0x1314  OpenDrainSelect for I/O port  128..143


'1' bit in OpenDrainSelect register makes corresponding GPIO an 
open drain output.
If OpenDrain is selected for an I/O bit , the DDR register is ignored.

0x1400	OutputInvert for I/O port  0..23
0x1404  OutputInvert for I/O port  24..47
0x1408  OutputInvert for I/O port  48..71
0x140C  OutputInvert for I/O port  72..95
0x1410  OutputInvert for I/O port  96..127
0x1414  OutputInvert for I/O port  128..143

A '1' bit in the OutputInv register inverts the cooresponding output bit.
This may be the GPIO output register bit or alternate source. The input is 
not inverted.

**************************************************
Fanuc serial pulsecoder interface. Interfaces to Fanuc serial 
absolute (aA) and serial incremental (aI) encoders

DataReg0

0x1500 32 bit serial data 0..31 for FAbs channel 0
0x1504 32 bit serial data 0..31 for FAbs channel 1
0x1508 32 bit serial data 0..31 for FAbs channel 2

Writing to DataReg0 starts a transfer request on the selected
FanucAbs module

...
DataReg1

0x1600 32 bit serial data 32..63 for FAbs channel 0
0x1604 32 bit serial data 32..63 for FAbs channel 1
0x1608 32 bit serial data 32..63 for FAbs channel 2
...
DataReg2

0x1700 12 bit serial data 64..75 for FAbs channel 0 (right justified)
0x1704 12 bit serial data 64..75 for FAbs channel 1 (right justified)
0x1708 12 bit serial data 64..75 for FAbs channel 2 (right justified)
...
DataReg 2 is also used for optional setup bits and a cable error status bit
Bit 31	CableErr     (R/O) If this bit is set, it indicates that the data 
                     polarity is wrong or the cable is unplugged
Bits 24..30	     Bit Length ((default 76) only writeable 
     		     if write setup enable bit is set
Bit 14..23	     Request length register, default 8 Usec. only writeable
    		     if write setup enable bit is set

Request length is request length register value * clocklow period


Data
Note: Fanuc serial encoder data is LSb first so is right shifted, 
and ends up left justified in the three data registers

0x1800 Control register 0 for FAbs channel 0
0x1804 Control register 0 for FAbs channel 1
0x1808 Control register 0 for FAbs channel 2
...

Control register 0 fields:

Bit 15		 Data Available set by transfer done, cleared by reading data 0 register
Bit 12..14	 Timer channel select
Bit 11		 Busy bit, set when transfer is started, 
   		 cleared when all data bits are recieved 
Bit 10		 RXGo set when recieve data start bit is detected
    		 cleared when all data bits are received     
Bit 9		 TStartMask, if set, timer start transfer is allowed
Bit 8		 GstartMask, if set global start transfer is allowed
Bit 7		 Setup Write Enable register


The timer select register selects the desired timer output
from the DPLL timer module: 0=Ref 1=timer1, 2=timer2, 3=timer3, 4=timer4
The TStartMask must be set to enable timer starts. 

0x1900 Control register 1 for FAbs channel 0
0x1904 Control register 1 for FAbs channel 1
0x1908 Control register 1 for FAbs channel 2
...

Control register 1
Bits 0..19	 Bitrate select register. (default set for 1.024 MHz bit rate)
     		 Only writeable if write setup enable bit is set
Bits 28..31	 Digital filter setting in clock low counts (default  0xF)
    		 Only writeble if write setup enable bit is set
i
Note a digital filter value of 0 will not work (only 1..15 are valid)

Receive bitrate is generated by a 20 bit phase accumulator. 
Bitrate is: (Control_Register_1/1048576)*ClockLow
re-arranged this is Control_Register_1 = 1048576*Bitrate/ClockLow

0x1A00 Global start register/busy register. Writing the global start register
(data is dont-care) starts transfers on all FanucAbs modules that have their 
global start mask set. 

Reading the Global start register returns the busy status (1=busy) 
of each channel, with bit# = channel# A channel is busy if the 
transfer is in progress or the data is stale (its already been read)  

Fanuc data format (76 bits): So far just for Aa64 (860-360-TXXX)
bits 0..4 	constant : = 0b00101
bit  5     	1=battery fail
bits 6,7	unknown = 0b10,a860-360 0b00,a860-370 
bit  8		1=un-indexed
bits 9..17	unknown, perhaps for higher res encoders
bits 18..33	16 bit absolute encoder data (0..65535 for one turn)
bits 34..35     unknown = 0b01
bits 36..51	16 bit absolute turns count
bits 52,53	unknown = 0b01
bits 54..63	10 bit absolute commutation encoder (four 0.1023 cycles per turn)
bits 64..70	unknown = 0b1100000
bits 71..75	ITU CRC-5 (calculated MSB first)

Note: Aa1000 (860-370-TXXX) is similar with bits 10..15 being 
additional lower order count bits (only 12..15 being of much use)
extending the 16 bit count from bits 18..33 with bits 12..15  
gives a resolution of 1048576 counts/turn

These encoders are absolute if the battery backup is maintained since the 
last homing. This can be determined by the status of the un-indexed bit, 
at least until the encoder crosses index. 

Surprisingly (well it surprised me anyway) the encoders maintain position 
and count with battery power alone. It appears that they keep the LEDS/
processor alive with a few 10s of uA of battery power (probably low duty 
cycle LED pulsing/analog circuits power cycling). 

This can be verified by reading the battery current and then moving the 
encoder, it goes from a few 10s of uA to many mA with a slow encoder move.

The commutation track is always absolute so can be used for commutation 
data regardless of the index status. Note that the commutation track
seems to be interpolated so is not better than maybe 1% accuracy
 
Note that the timing/baudrate are all precalculated so should not need
changing, but can be changed by setting the setup enable bit in control reg 0

**************************************************

Scaler-counter

The scaler counter component is a simple multi-channel frequency 
counter for multi channel A-Ds and other simple rate counting 
applications. The counters are 16 bits wide and always in pairs.
both the current count and the latched count are available. A common
free running 32 bit timestamp register is provided for rate calculations
The counts are all latched when the timebase register is read, allowing 
simple DeltaCount/DeltaTime rate calculations.
The counters have a 3 clock input digital filter that limits the
maximum count rate to ClockLow/6 (minimum detectable pulse width 3/Clocklow)

Count registers (read only)

Bits 15..0	CountA
Bits 31..16	CountB

0x1B00		Count register 0
0x1B04		Count register 1
0x1B08		Count register 2
0x1B0C		Count register 3
0x1B10		Count register 4
...

Latched count registers read only

Bits 15..0	Latched CountA
Bits 31..16	Latched CountB

0x1C00		Latched Count register 0
0x1C04		Latched Count register 1
0x1C08		Latched Count register 2
0x1C0C		Latched Count register 3
0x1C10		Latched Count register 4
...

ScalerTime register read only

0x1D00		32 bit timestamp up counter running at ClockLow
		Reads of the timestamp register latch all counters



********************************************************************
Step generator for step/dir generation. Works as a velocity mode servo
with loop closed by host


Step/dir generators currently 48 bit accumulator = 16 bits full step, 
32 fractional step/rate. That is a 48 bit accumulator with a 32 bit rate 
value (sign extended) and added to accumulator.

 Step rate registers : Write only

0x2000	32 bit rate register for StepGen 0 
0x2004 	32 bit rate register for StepGen 1  
0x2008	32 bit rate register for StepGen 2
0x200C	32 bit rate register for StepGen 3
0x2010	32 bit rate register for StepGen 4
0x2014	32 bit rate register for StepGen 5
0x2018	32 bit rate register for StepGen 6
0x201C	32 bit rate register for StepGen 7
...

 32 bit top of accumulator = 16.16 fullstep.fractionalstep : Read/write

0x2100	32 bit full.fractional accum for StepGen 0
0x2104 	32 bit full.fractional accum for StepGen 1  
0x2108	32 bit full.fractional accum for StepGen 2
0x210C	32 bit full.fractional accum for StepGen 3
0x2110	32 bit full.fractional accum for StepGen 4
0x2114	32 bit full.fractional accum for StepGen 5
0x2118	32 bit full.fractional accum for StepGen 6
0x211C	32 bit full.fractional accum for StepGen 7
...

Mode registers (2 bits Write only)
00 = Step/Dir
01 = Up/Down
10 = Quadrature
11 = Table Driven

0x2200	2 bit mode register for StepGen 0
0x2204 	2 bit mode register for StepGen 1  
0x2208	2 bit mode register for StepGen 2
0x220C	2 bit mode register for StepGen 3
0x2210	2 bit mode register for StepGen 4
0x2214	2 bit mode register for StepGen 5
0x2218	2 bit mode register for StepGen 6
0x221C	2 bit mode register for StepGen 7
...

DIR Setup time = how long DIR must be valid before step 
pulses may be issued.
Max time for 14 bits at ClockLow = 33 MHz = ~480 uS. 
At ClockLow = 50 MHz = ~320 uS (dont use 0)

Write only

0x2300	14 bit DIR setup time register for StepGen 0
0x2304 	14 bit DIR setup time register for StepGen 1  
0x2308	14 bit DIR setup time register for StepGen 2
0x230C	14 bit DIR setup time register for StepGen 3
0x2310	14 bit DIR setup time register for StepGen 4
0x2314	14 bit DIR setup time register for StepGen 5
0x2318	14 bit DIR setup time register for StepGen 6
0x231C	14 bit DIR setup time register for StepGen 7
...

DIR Hold time = how long DIR most remain valid after 
a step pulse has been issued. 
Max time for 14 bits at ClockLow = 33 MHz = ~480 uS. 
At ClockLow = 50 MHz = ~320 uS (dont use 0)

Write only

0x2400	14 bit DIR hold time register for StepGen 0
0x2404 	14 bit DIR hold time register for StepGen 1  
0x2408	14 bit DIR hold time register for StepGen 2
0x240C	14 bit DIR hold time register for StepGen 3
0x2410	14 bit DIR hold time register for StepGen 4
0x2414	14 bit DIR hold time register for StepGen 5
0x2418	14 bit DIR hold time register for StepGen 6
0x241C	14 bit DIR hold time register for StepGen 7
...

Pulse length = Active time of output pulse (N+1 clocks).
Max time for 14 bits at ClockLow = 33 MHz = ~480 uS. 
At ClockLow = 50 MHz = ~320 uS (dont use 0)

Write only

0x2500	14 bit pulse width register for StepGen 0
0x2504 	14 bit pulse width register for StepGen 1  
0x2508	14 bit pulse width register for StepGen 2
0x250C	14 bit pulse width register for StepGen 3
0x2510	14 bit pulse width register for StepGen 4
0x2514	14 bit pulse width register for StepGen 5
0x2518	14 bit pulse width register for StepGen 6
0x251C	14 bit pulse width register for StepGen 7
...

Pulse Idle = Inactive time of output pulse (N+1 clocks).
Max time for 14 bits at ClockLow = 33 MHz = ~480 uS. 
At ClockLow = 50 MHz = ~320 uS 

Write only

0x2600	14 bit pulse idle width register for StepGen 0
0x2604 	14 bit pulse idle width register for StepGen 1  
0x2608	14 bit pulse idle width register for StepGen 2
0x260C	14 bit pulse idle width register for StepGen 3
0x2610	14 bit pulse idle width register for StepGen 4
0x2614	14 bit pulse idle width register for StepGen 5
0x2618	14 bit pulse idle width register for StepGen 6
0x261C	14 bit pulse idle width register for StepGen 7
...

Output sequence table. This is a single write location where the 
table sequence data for table driven step generator output is stored.
Data is written sequentially here from last to first data word in the 
sequence. Default table width is 6 bits.
Table data is in LSBs of written word.

0x2700	Table sequence data setup register for StepGen 0
0x2704	Table sequence data setup register for StepGen 1
0x2708	Table sequence data setup register for StepGen 2
0x270C	Table sequence data setup register for StepGen 3
0x2710	Table sequence data setup register for StepGen 4
0x2714	Table sequence data setup register for StepGen 5
0x2718	Table sequence data setup register for StepGen 6
0x271c	Table sequence data setup register for StepGen 7
...

TableLength register: 4 bit register that determines table sequence 
length. Sequence length is TableLength+1, Maximum length is 16 steps
Only used in table mode.

0x2800	Table sequence length register for StepGen 0
0x2804	Table sequence length register for StepGen 1
0x2808	Table sequence length register for StepGen 2
0x280C	Table sequence length register for StepGen 3
0x2810	Table sequence length register for StepGen 4
0x2814	Table sequence length register for StepGen 5
0x2818	Table sequence length register for StepGen 6
0x281c	Table sequence length register for StepGen 7

...

0x2900  32 bit master DDS for all stepgens (compile time option,
may be disabled)

Step generator addition rate is (ClockLow*MasterDDSVal/2^32)

Probably just set to 0xffffffff for most applications.

WaveGen: simple table driven waveform generator

WaveGenRate

32 bit register, sets rate of steps through table = WaveGenRate/2^32*ClockHigh 

0x2B00 wavegen 0 rate
0x2B04 wavegen 1 rate
0x2B08 wavegen 2 rate
0x2B0C wavegen 3 rate
...

WaveGenPDMRate

8 bit register, sets PDM clock, PDM clock = ClockHigh/(WaveGenPDMRate+2)
any rate with MSB set will divide by one (0x80 or >)

0x2C00 wavegen 0 PDM rate
0x2C00 wavegen 1 PDM rate
0x2C00 wavegen 2 PDM rate
0x2C00 wavegen 3 PDM rate
...

WaveGenLength

10 bit register, sets table length (table pointer range is 0 --> WaveGenLength)

0x2D00 wavegen 0 table length 
0x2D04 wavegen 1 table length 
0x2D08 wavegen 2 table length 
0x2D0C wavegen 3 table length 
...

WaveGenTablePtr

10 bit register for host access to table pointer, writes to table 
must first write address pointer, and the write data.

0x2E00 wavegen 0 table pointer
0x2E04 wavegen 1 table pointer
0x2E08 wavegen 2 table pointer
0x2E0C wavegen 3 table pointer

...
 
16 bit register for host access to table data, writes to table 
must first write address pointer, and the write data.

0x2F00 wavegen 0 table data
0x2F04 wavegen 1 table data
0x2F08 wavegen 2 table data
0x2F0C wavegen 3 table data 

Table Data is 12 bit offset binary(2048 is '0") plus 4 trigger bits
trigger bits are top 4 bits of data

Bit 15    Trigger3         
Bit 14    Trigger2
Bit 13    Trigger1
Bit 12    Trigger0
Bit 11..0 Waveform data	


QuadratureCounter Type 2 (with timestamp)
32 bit register: bottom 16 bits are count, 
top 16 bits are timestamp of last count change
Writes to counter register clear the counter.

0x3000 quad counter 0	
0x3004 quad counter 1	
0x3008 quad counter 2	
0x300C quad counter 3	
0x3010 quad counter 4	
0x3014 quad counter 5	
0x3018 quad counter 6	
0x301c quad counter 7	
...

The time stamp allows reciprocal time (DeltaCount/DeltaTime) 
velocity calculation for better estimation of motor velocity 
at low counts/sample interval.


QuadratureCounter latch/Control register
32 bit register: top 16 bits are latched (by index) count, 
bottom 16 bits is control register.

0x3100 quad counter latch/CCR 0	
0x3104 quad counter latch/CCR 1	
0x3108 quad counter latch/CCR 2	
0x310C quad counter latch/CCR 3	
0x3110 quad counter latch/CCR 4	
0x3114 quad counter latch/CCR 5	
0x3118 quad counter latch/CCR 6	
0x311c quad counter latch/CCR 7	
...

Bit 31..16 = Latched count (Latch on index)

Bit 15	Quad Error: set if quadrature sequence error
Bit 14	AB mask polarity: A*B must be high for index gate
Bit 13	LatchOnProbe 1 = Latch count on probe (Version 3 counters only)
Bit 12	ProbePolarity 1 = active high         (Version 3 counters only)
Bit 11  Quad filter (0 = 3 clocks 1 = 15 clocks)
Bit 10	CounterMode 0 = Quadrature, 1 = up/down
Bit 9	UseIndexMask 1 = use mask
Bit 8	IndexMask Polarity 1=active high
Bit 7	ABgateIndex 1 = gate index signal with A,B
Bit 6	JustOnce 1 = ClearOnIndex, LatchOnIndex, LatchOnProbe happen only once
Bit 5	ClearOnIndex 1 = Clear count on index 
Bit 4	LatchOnIndex 1 = Latch count on index
Bit 3	IndexPol 1 = active high
Bit 2	read only realtime index signal
Bit 1	read only realtime B signal
Bit 0	read only realtime A signal

0x3200  TSSDiv 16 bit time stamp programmable divider (in LSBs) (R\W)

Sets quadrature counter reference clock for timestamp.

Timestamp count rate is ClockLow/(TSDiv+2). 
Any divisor with MSb set = divide by 1

0x3300  TSCount 16 bit time stamp counter (read only) 

0x3400  QfilterRate 12 bit Quadrature counter filter rate
count rate is ClockLow/(QFilterRate+2). 
Any divisor with MSb set = divide by 1


MuxedQuadratureCounter Type 2 (with timestamp)
Note: Multiplexed counters have same register bits but differing
count rate limits than normal quadrature counters

32 bit register: bottom 16 bits are count, 
top 16 bits are timestamp of last change
Writes to counter register clear the counter.

0x3500 quad counter 0	
0x3504 quad counter 1	
0x3508 quad counter 2	
0x350C quad counter 3	
0x3510 quad counter 4	
0x3514 quad counter 5	
0x3518 quad counter 6	
0x351c quad counter 7	
...

The time stamp allows reciprocal time (DeltaCount/DeltaTime) 
velocity calculation for better estimation of motor velocity 
at low counts/sample interval

MuxedQuadratureCounter latch/Control register
32 bit register: top 16 bits are latched (by index) count, 
bottom 16 bits is control register

0x3600 quad counter latch/CCR 0	
0x3604 quad counter latch/CCR 1	
0x3608 quad counter latch/CCR 2	
0x360C quad counter latch/CCR 3	
0x3610 quad counter latch/CCR 4	
0x3614 quad counter latch/CCR 5	
0x3618 quad counter latch/CCR 6	
0x361c quad counter latch/CCR 7	
...

Bit 31..16 = Latched count (Latch on index)

Bit 15	Quad Error: set if quadrature sequence error
Bit 14	AB mask polarity: A*B must be high for index gate
Bit 13	LatchOnProbe 1 = Latch count on probe (Version 3 counters only)
Bit 12	ProbePolarity 1 = active high         (Version 3 counters only)
Bit 11  Quad filter (0 = 3 clocks 1 = 15 clocks)
Bit 10	CounterMode 0 = Quadrature, 1 = up/down
Bit 9	UseIndexMask 1 = use mask
Bit 8	IndexMask Polarity 1=active high
Bit 7	ABgateIndex 1 = gate index signal with A,B
Bit 6	JustOnce 1 = ClearOnIndex, LatchOnIndex, LatchOnProbe happen only once
Bit 5	ClearOnIndex 1 = Clear count on index 
Bit 4	LatchOnIndex 1 = Latch count on index
Bit 3	IndexPol 1 = active high
Bit 2	read only realtime index signal
Bit 1	read only realtime B signal
Bit 0	read only realtime A signal

0x3700  MuxedTSSDiv 16 bit time stamp programmable divider (in LSBs) (R\W)

Sets quadrature counter reference clock for timestamp.

MuxedTimestamp count rate is ClockLow/(MuxedTSDiv+2). 
Any divisor with MSb set = divide by 1

0x3800  MuxedTSCount 16 bit time stamp counter (read only) 

0x3900  QfilterRate 12 bit Quadrature counter filter rate 
(bits 0 ..11) 
count rate is ClockLow/(QFilterRate+2). 
Any divisor with MSb (bit 11) set = divide by 1

Version 4 and greater muxed encoders have 4 bit muxed data deskew register 
in top nibble (bits 28 ..31) of the QFilterRate register. 
This delays the sampling time of muxed encoder data by 0 to 15 ClockLow 
periods to accomodate long cables and isolation delays and allow higher 
multiplex rates. 

Notes about quadrature filter rate:

QFilterRate sets the sampling rate for all quadrature counters input filters.
Input filtering should be set with as long a time constant as possible, 
especially when using TTL encoders.

The time constant chosen should give a fair (say 30%) margin of quadrature 
counter maximum count rate above the hardwares maximum possible count rate.

For example with a 33MHz ClockLow and QfilterRate = 0xFFF (divide by one):

With the filter bit off, the the input filter requires 3 clocks to 
recognize an input change = ~90 nS. This gives a maximum input frequency 
of 1/180 nS = ~5MHz or a maximum quadrature (4X) count rate of ~ 16MHz 
(limited to 1/2 of 33 MHz) 

With the filter bit on, the the input filter requires 15 clocks to 
recognize an input change = ~450 nS. This gives a maximum input frequency 
of 1/900 nS = ~1.1MHz or a maximum quadrature (4X) count rate of ~ 4.4 MHz

This is still much faster than needed for most applications so the QFilterRate
register allows lowering the filter sample rate. For example with the 
Qfilterrate register set to divide by 10 (QFilterRate loaded with 8), 
the input filter sample rate at 33 MHz ClockLow would be 3.3 MHz:

With the filter bit off, the the input filter requires 3 clocks to 
recognize an input change = ~900 nS. This gives a maximum input frequency 
of 1/1800 nS = ~500 KHz or a maximum quadrature (4X) count rate of ~ 2MHz

With the filter bit on, the the input filter requires 15 clocks to 
recognize an input change = ~4500 nS. This gives a maximum input frequency 
of 1/9000 nS = ~110 KHz or a maximum quadrature (4X) count rate of ~ 440 KHz

440 KHz is adequate for most normal applications = 13200 RPM with a 500 line 
(2000 count) encoder, and has the benefit that noise rejection is very good, 
input noise pulses less than 4500 nS will be ignored. Most PWM generated 
noise pulses tend to be short, determined by the PWM voltage and the time 
constant of the PWM to encoder wire capacitance and the encoder output 
resistance. This output resistance is often quite high in low cost TTL 
encoders, with outputs that are just open collector comparators with pullup 
resistors. These encoders are very susceptible to low going noise pulses, and 
benefit greatly by maximizing the filter time constant.

Lowering the quadrature filter rate has the disadvantage of reducing the 
quadrature edge timing resolution when inverse time velocity estimation is 
used, however, this is normally not a problem as even at a 1 MHz sample rate, 
the 1 uSec timing uncertainty will be swamped out by the quadrature phase 
inaccuracies in typical encoders. 

For multiplexed quadrature counters, the multiplex channel rate is 1/2 the 
filter rate. Due to flat cable signal integrity and time of flight issues the 
multiplex channel rate should not be higher than 16 MHz, with lower rates 
needed with longer cable runs. This means that the filter rate should not 
be set higher than 16 MHz. The hardware default for the multiplexed flter 
rate register is set to divide by 4 which gives a multiplex rate of
4.166 MHz with a 33 MHz clklow and 6.25 MHz with a 50 MHZ clklow. 

Note that fixed clock skew can be adjusted to accomodate long cables and 
encoder isolation in muxed encoder version 4 and greater. This alo allow highermux rates
The hardware default filter rate is set to divide by 1 for non-multiplexed 
counters.


Resolver Module, 6 Channel resolver input module for 7I49 and 7I51 
daughter cards. Currently about 14-15 bit resolution, 10KHz, 5KHz and 2.5 KHz
selectable frequencies.

0x3A00	 Processor command register 
This is for access to the resolver modules parameters, normally not needed
except for debug and parameter tweaking or setting  resolver frequency

Bit 15	    Write bit
Bit 14	    Reset DSP/firmware download bit
Bit 13	    Do-it bit	 
Bit 11	    Command bit
Bits 9..0  Parameter address   

Firmware is host side downloadable so neither bitfile recompilation nor 
Xilinx blockram loading tools are required to try new firmware.

Currently only 4 commands:
0x0800	      Reload waveform with current magnitude 
0x0801	      Set excitation to 2.5 KHz
0x0802	      Set excitation to 5 KHz
0x0803	      Set Excitation to 10 KHz

0x3B00	 32 bit Processor data register
This is for access to the resolver modules parameters, normally not needed
except for debug and parameter tweaking or setting resolver frequency

0x3C00  32 bit channel status register
The channel status register indicates the validity of the resolver data
Bits 5..0   Channel valid bits bit 0 - channel 0 valid etc


0x3D00    32 bit velocity 0
0x3D04    32 bit velocity 1
0x3D08    32 bit velocity 2
0x3D0C    32 bit velocity 3
0x3D10    32 bit velocity 4
0x3D14    32 bit velocity 5
0x3D18    32 bit unused
0x3D1C    32 bit unused
Resolver velocity readout, updated at resolver frequency. 
Units are 2^32 * resolver electrical rotations/resolver frequency


0x3E00	  32 bit position 0
0x3E04	  32 bit position 1
0x3E08	  32 bit position 2
0x3E0C	  32 bit position 3
0x3E10	  32 bit position 4
0x3E14	  32 bit position 5
0x3E18	  32 bit unused
0x3E1C	  32 bit unused

Resolver position readout, updated at 256*resolver frequency
Units are 2^32 * Resolver electrical rotations

PWM generators (With FPGA compile time constant PWM width = 13)

0x4000	PWMVal 0 Right justified 9..12 bit PWM in bits 27..16 DIR is bit 31
0x4004	PWMVal 1 Right justified 9..12 bit PWM in bits 27..16 DIR is bit 31
0x4008	PWMVal 2 Right justified 9..12 bit PWM in bits 27..16 DIR is bit 31
0x400C	PWMVal 3 Right justified 9..12 bit PWM in bits 27..16 DIR is bit 31
0x4010	PWMVal 4 Right justified 9..12 bit PWM in bits 27..16 DIR is bit 31
0x4014	PWMVal 5 Right justified 9..12 bit PWM in bits 27..16 DIR is bit 31
0x4018	PWMVal 6 Right justified 9..12 bit PWM in bits 27..16 DIR is bit 31
0x401C	PWMVal 7 Right justified 9..12 bit PWM in bits 27..16 DIR is bit 31
...
 	
PWM mode registers 6 bits

Bit 1,0 = width select  (With FPGA compile time constant PWM width = 13)
00 = 9 bit PWM
01 = 10 bit PWM
10 = 11 bit PWM
11 = 12 bit PWM

Bit 2 = PWM mode select
0 = Straight (Sawtooth) PWM     
1 = Symmetrical (Triangle) PWM

Bit 4,3 = PWM output mode select
00 = Normal Sign Magnitude PWM&DIR outputs normal
01 = Normal Sign Magnitude PWM&DIR outputs swapped (for locked antiphase)
10 = Up/down mode
11 = PDM mode (12 bits)

Bit 5 = Double Buffered mode
When bit 5 is set, the PWMval register is not updated until the beginning of a 
PWM cycle, avoiding extra transitions in the output PWM waveform. This adds 
an extra delay of 0 to PWMWidth/PWMClock (normal mode) or PWMWidth*2/PWMClock
(Symmetrical mode) between when the host writes the PWMVal register and the 
PWM output is updated. This mode should be used with HBridges. 


0x4100 PWM mode select register 0
0x4104 PWM mode select register 1
0x4108 PWM mode select register 2
0x410C PWM mode select register 3
0x4110 PWM mode select register 4
0x4114 PWM mode select register 5
0x4118 PWM mode select register 6
0x411C PWM mode select register 7
...

0x4200  16 bit PWM gen master rate DDS (PWMCLOCK = CLKHIGH*Rate/65536) 
        PWM rate will be PWMCLOCK/(2^PWMBITS) for normal PWM
        and PWMCLOCK/(2^(PWMBITS+1)) for symmetrical mode PWM.

0x4300	16 bit PDM gen master rate DDS (PDMCLOCK = CLKHIGH*Rate/65536) 
        PDM rate will be PDMCLOCK/(4096).

0x4400	Enable register for PWM. Doesn't actually change PWM but is used for 
        enabling PWM driven devices (the ENA pin). 1 bit per PWM channel. 
        Active high --> '1' means enabled = '0' output pin level.

Bit 0   PWM channel 0 enable
Bit 1   PWM channel 1 enable
Bit 2   PWM channel 2 enable

PWM/PDM Notes: 

1. For 7I33, 7I33T and 7I33TA that filter the PWM to generate analog voltages, 
   PDM mode should be used. Optimum PDM rate for best trade-off between ripple 
   and linearity for 7I33, 7I33T and 7I33TA is about 6 MHz 
   (PDM rate register approx 0x0fff) This gives about 13 bits of resolution 
   and 10 bit linearity/ripple.
   For 7I48 that uses up/down PWM mode, the highest 12 bit PWM frequency 
   should be used and the mode register set to 0x33 (12 bit, sawtooth, 
   up/down, double buffered)

2. Double buffering should be used where the PWM directly drives an HBridge. 
   Double buffering prevents extra transitions on the PWM output due to host 
   updates, which waste power in switching losses and could cause malfunction 
   on some HBridges. Double buffering should _not_ be used with PDM output! 
   Double Buffering will add a 0 to 1/PWMRate  delay in the PWM output if the
   host does not update the PWM generator synchronously with the PWM rate..


Three Phase PWM generator

0x4500 TPPWMVal 0 
0x4504 TPPWMVal 1 
0x4508 TPPWMVal 2 
0x450C TPPWMVal 3 
0x4510 TPPWMVal 4 
...

Bits 0..9    = 10 bit PWM value for PWMA
Bits 19..10  = 10 bit PWM value for PWMB
Bits 29..20  = 10 bit PWM value for PWMC

0x4600 TPPWM ENA REG 0
0x4604 TPPWM ENA REG 1
0x4608 TPPWM ENA REG 2
0x460C TPPWM ENA REG 3
0x4610 TPPWM ENA REG 4
...

Bit 0 =  Enable, Active high
Bit 1 =  Fault flag, active high

0x4700 TPPWM SETUP REG 0
0x4704 TPPWM SETUP REG 1
0x4708 TPPWM SETUP REG 2
0x470C TPPWM SETUP REG 3
0x4710 TPPWM SETUP REG 4
...

Bits 0..8 = Deadzone time in units of 2/TPWMCLK
Bit 15 =    Fault Input polarity 1 = fault on high, 0 = fault on low
Bits 16..26 = Sample time in units of TPWMCLK 

0x4800 TPPWM PWM RATE REGISTER

Bits 0..15 = 16 bit DDS that sets TPWMCLK, TPWMCLK = HSCLK*RATE/65536
TPPWM PWM rate will be TPWMCLK/2048

TPPWM Notes:

TPPWM provides gate drive signals for high and low sides of a 3 phase 
IGBT/MOSFET module. 

PWM mode is triangular so that ripple frequency is twice the PWM rate. 
TPPWM PWM output is always double buffered so that the PWM output values 
will only change synchronously with the PWM period. This means that the PWM 
update may be delayed from 0 to 1/(TPPPWM rate) after the host write.

The enable bit must be set to enable PWM outputs. The external enable signal 
follows the state of the internal enable bit. An active fault input clears the 
enable bit, sets the fault status bit and disables all PWM outputs. 
There is a ~70 nS noise filter on the fault input to prevent short glitches 
from triggering a fault. Fault is intended to connect to over current 
sense circuitry. 

The sample time register determines the time during the PWM cycle where a 
ADC sample pulse is generated, with a sample reg value of 1024 being the 
center of the PWM cycle, for SPI or other slow ADCs, the sample time can be 
moved earlier in the cycle to compensate for the sampletime to ADC aquisition 
time delays. 

Deadtime is in units of 2/TPWMCLK. Deadtime is subtracted from on time and 
added to off time symmetrically. For example with 20 KHz PWM (50 uSec period),
50% duty cycle and zero dead time, the PWM and NPWM outputs would be square 
waves (NPWM being inverted from PWM) with high times of 25 uS. With the same 
settings but 1 uS of deadtime, the PWM and NPWM outputs would both have high 
times of 23 uS (25 - (2X 1 uS), 1 uS per edge) 


BISS encoder module. Unidirectional BISS interface, 512 bits maximum

BISS Data register

0x4900 BISS 0 32 bit data register
0x4904 BISS 1 32 bit data register
0x4908 BISS 2 32 bit data register
...

This register is the top of a 16 deep x 32 wide LIFO stack. 
BISS data sizes greater that 32 bits are read by muliple reads 
of the same address. Data is returned LSW first and right justified. 
Data beyond the MSb should be ignored.
Writes to the data register start a data transfer in selected channel.

BISS Control register0

0x4A00 BISS 0 Control register0
0x4A04 BISS 1 Control register0
0x4A08 BISS 2 Control register0
...

Bits 31..16	BISS DDS data rate register
Bits 15..10	BISS Data digital filter time constant
Bits 9..0	BISS data length in bits (1 to 512)

The BISS data rate field sets the BISS clock rate. This rate is 
(ClockHigh/65536)*BISS_DataRateReg.

The BISS digital fiter time constant selects the time constant 
for the BISS data input in units of ClockHigh periods. 
Suggested value is BISS clock period /2. For example for a CLockHigh 
frequency of 100 MHz, and a 10 MHz BISS clock, a register value of 5  
(5x 10 nS = 50 nS = 1/2 of BISS clock period is suggested). 
Note that a value of 0 is illegal and will prevent data transfer. 


BISS Control register1

0x4B00 BISS 0 Control register1
0x4B04 BISS 1 Control register1
0x4B08 BISS 2 Control register1

Bit 15 	      	Data Available (read only)i
Bits 14..12	Timer select register
Bit 11		RX Go (read only)
Bit 9		TStart Mask
Bit 8		PStart Mask 		
Bits 4..0	LIFO level (number of pops needed to read all data - read only)


The timer select register selects the desired timer output 
from the DPLL timer module: 0=Ref 1=timer1, 2=timer2, 3=timer3, 4=timer4
The TStartMask must be set to enable timer starts. The PStartMask 
must be set to enable global starts.

BISS Global start register/busy status register

0x4C00	    Writes to the global start register start data transfers in all
	    BISS module that have the PStartMask set
	    Reads here read back the busy status of each BISS module
	    bit 0 high = module 0 busy, bit 1 high = module 1 busy etc


Twiddler Module: Smart GPIO bit twiddler, 1 to 31 bits of GPIO 
(input, output, or I/O) default 1K program ROM, 512 bytes of RAM
internal hardware includes free running timer, (preset to 10 MHz)
buffered I/O (update or sample all I/O at once) 8 bit 33 or 50 mips
processor, doorbell registers to indicate host parameter write, 


0x4D00	 Processor command register 
This is for access to the smart twiddler modules parameters, allows reading 
and writing parameters. Parameter access is just for setup and discovery.
not realtime.

Bit 15	    Write bit
Bit 14	    Reset uProc/firmware download bit
Bit 13	    Do-it bit	 
Bits 11..0  Parameter address   

Firmware is host side downloadable so neither bitfile recompilation nor 
Xilinx blockram loading tools are required to try new firmware.

0x4E00	 8 bit Processor data register
This is for access to the twiddler modules parameters, normally not needed
except for debug and parameter tweaking.



0x4F00 	   32 bit read/write embedded processor communication register 0
0x4F04 	   32 bit read/write embedded processor communication register 1
0x4F08 	   32 bit read/write embedded processor communication register 2
0x4F0C 	   32 bit read/write embedded processor communication register 3

Default is four 32 bit read/write host communication registers


Simple SPI inteface. The simple SPI interface is most suited for SPI devices
with only one logical unit per SPI interface (like single channel ADCs, DACs or 
SPI I/O ports)

SPI SREG 32 bits (for data less than 32 bits data is right justified)

Writes here load shift register and start frame transmission

0x5000 SPI SREG 0
0x5004 SPI SREG 1
0x5008 SPI SREG 2
0x500C SPI SREG 3
0x5010 SPI SREG 4
0x5014 SPI SREG 5
...

SPI bit count register

Bits 0..5 = bits per SPI frame (bits = N+1) ie 0x1f = 32 bit frame
Bit 6 = CPOL = Clock polarity ( FreeScale SPI spec compatible definitions)
Bit 7 = CPHA = Clock Phase
Bit 8 = DontClearFrame = Dont clear frame at EOT (for transfers > 32 bits)
Bit 31 = DAV = data ready
Bit 30 = Busy

0x5100 SPI bit count register 0
0x5104 SPI bit count register 1
0x5108 SPI bit count register 2
0x510C SPI bit count register 3
0x5110 SPI bit count register 4
0x5114 SPI bit count register 5
...
SPI bit rate register

Bits 0..7 = programmable divider, SPI bit rate is CLOCKLOW/((N+1)*2) 
Maximum rate (N=0) is 24 MHz (5I22 with 48 MHz clock) or 16.66 (5I20 with 
33MHz clock. Minmum rate (N=255) is 93.75 KHz (48 MHz clock) or 
~65 KHz (33 MHz clock)

0x5200 SPI bit rate register 0
0x5204 SPI bit rate register 1
0x5208 SPI bit rate register 2
0x520C SPI bit rate register 3
0x5210 SPI bit rate register 4
0x5214 SPI bit rate register 5
...


BinOsc utility

The Binonsc interface is a simple binary counter with outputs that drive the 
I/O pins. BinOsc only has one control register and one bit in the register 
(enable)

0x5300

Bit 0	Enable		counter is cleared if 0 and free runs if 1


Buffered SPI interface (BSPI)

The buffered SPI interface is a FIFO buffered SPI interface 
that supports up to 16 devices on a single SPI port. Each device 
can have different bit lengths (up to 32 bits), different data rates, 
and a different code on the chip select bits. This information is 
stored in the channel descriptor for each SPI peripheral connected 
to a BSPI interface. The buffered SPI interface is most suited to use 
with SPI devices that have multiple channels per interface (multiple 
channel ADCs, DACs, or multiple devices sharing a SPI interface)
The transmit buffering allows the host to write multiple channel data 
without waiting for the SPI data transmission to complete. 
The receive buffering allows the host to gather all the received SPI 
data whenever convenient.

SPI interface data register

32 bits (for data less than 32 bits data is right justified)

0x5400 BSPI FIFO port 0
0x5440 BSPI FIFO port 1
0x5480 BSPI FIFO port 2
0x54C0 BSPI FIFO port 3
...
The SPI data FIFO is the location of a 16 deep transmit
and 16 deep receive FIFO for the SPI interface. There is only 
one transmit and one receive FIFO per buffered SPI interface
but the FIFO interface spans 16 doublewords of address space. 
This is so that when data is written to the FIFO, the address 
bits are written into the FIFO as well. These address bits select 
the channel descriptor at the SPI end of the transmit FIFO. 
The receive FIFO also spans the same address space but the 
read address within the range is dont-care.

0x5500 BSPI channel descriptor setup registor 0
0x5540 BSPI channel descriptor setup registor 1
0x5580 BSPI channel descriptor setup registor 2
0x55C0 BSPI channel descriptor setup registor 3
...

The channel descriptor setup location is where the channel 
descriptors for up to 16 SPI peripherals are written. The 
channel descriptors are written in last to first order, in 
other words, to setup  16 channel descriptors, first the 
channel descriptor for SPI device 15 is written, then the 
channel descriptor for SPI device 14 is written, repeating 
the decending device order until the channel descriptor for 
SPI device 0 is written.

ChannelDescriptor:

Bits 0..5    = bits per SPI frame (bits = N+1) ie 0x1f = 32 bit frame
Bit 6 = CPOL = Clock polarity ( FreeScale SPI spec compatible definitions)
Bit 7 = CPHA = Clock Phase
Bits 8..15   = Programmable divider, SPI bit rate is CLOCKLOW/((N+1)*2) 
               Maximum rate (N=0) is 24 MHz (5I22 with 48 MHz clock) or 16.66 
               (5I20 with 33MHz clock, Minmum rate (N=255) is 93.75 KHz 
               (48 MHz clock) or ~65 KHz (33 MHz clock)
Bits 16..19   = Chip select bits for SPI interface
     	      	The BSPI chip select bits are transfered directly to the
                chip select output pins. These normally used as addresses, 
                decoded and conditioned with the /FRAME signal externally. 
                This is for applications that need to minimize the number 
                of I/O pins.
Bits 24..28   = Chip select delay = chip select valid delay before and 
                after frame in (N+1 CLOCKLOW periods, N = 0 ..15
                n>15 = 0 delay.
Bit 29	      = Sample input data late. If this bit is set, slave output data
                is sampled 1/2 clock cycle late. This is useful for higher 
                clock rates, and for systems with large delays from 
                clock to slave data valid.
Bit 30        = Dont_Clear_Frame. If set, leave frame asserted at EOT.
                This is for SPI devices that send or recv more than 32 bits 
                of data. for example a 48 bit SPI access can be built from 
                access via a descriptor setup for 32 bits and  
                Dont_Clear_Frame set, followed  by access via a descriptor 
                setup for 16 bit access with Dont_Clear_Frame cleared.	
Bit 31 	      = Dont_Echo. If set, dont push SPI returned data on
                receive FIFO. (for output only SPI devices) 

0x5600	BSPI FIFOCount register 0
0x5640	BSPI FIFOCount register 1
0x5680	BSPI FIFOCount register 2
0x56C0	BSPI FIFOCount register 3
  
FIFOCount:

Bits 0..4     = Receve FIFO data counter
Bits 8..12    = Transmit FIFO data counter

If FIFO count register is written (data is dont care), both FIFOs will be 
cleared


Decoded Buffered SPI interface (DBSPI) (same as BSPI but decoded outputs)

The SPI interface is a FIFO buffered SPI interface 
that supports up to 16 devices on a single SPI port. Each device 
can have different bit lengths (up to 32 bits), different data rates, 
and a different chip enabled on the chip select bits. This information is 
stored in the channel descriptor for each SPI peripheral connected 
to a DBSPI interface. 

SPI interface data register

32 bits (for data less than 32 bits data is right justified)

0x5700 DBSPI FIFO port 0
0x5740 DBSPI FIFO port 1
0x5780 DBSPI FIFO port 2
0x57C0 DBSPI FIFO port 3
...
The SPI data FIFO is the location of a 16 deep transmit
and 16 deep receive FIFO for the SPI interface. There is only 
one transmit and one receive FIFO per buffered SPI interface
but the FIFO interface spans 16 doublewords of address space. 
This is so that when data is written to the FIFO, the address 
bits are written into the FIFO as well. These address bits select 
the channel descriptor at the SPI end of the transmit FIFO. 
The receive FIFO also spans the same address space but the 
read address within the range is dont-care.

0x5800 DBSPI channel descriptor setup registor 0
0x5840 DBSPI channel descriptor setup registor 1
0x5880 DBSPI channel descriptor setup registor 2
0x58C0 DBSPI channel descriptor setup registor 3
...

The channel descriptor setup location is where the channel 
descriptors for up to 16 SPI peripherals are written. The 
channel descriptors are written in last to first order, in 
other words, to setup  16 channel descriptors, first the 
channel descriptor for SPI device 15 is written, then the 
channel descriptor for SPI device 14 is written, repeating 
the decending device order until the channel descriptor for 
SPI device 0 is written.

ChannelDescriptor:

Bits 0..5    = bits per SPI frame (bits = N+1) ie 0x1f = 32 bit frame
Bit 6 = CPOL = Clock polarity ( FreeScale SPI spec compatible definitions)
Bit 7 = CPHA = Clock Phase
Bits 8..15   = Programmable divider, SPI bit rate is CLOCKLOW/((N+1)*2) 
               Maximum rate (N=0) is 24 MHz (5I22 with 48 MHz clock) or 16.66 
               (5I20 with 33MHz clock, Minmum rate (N=255) is 93.75 KHz 
               (48 MHz clock) or ~65 KHz (33 MHz clock)
Bits 16..19   = Chip select bits for SPI interface
                The DBSPI interface is identical to the BSPI interface with 
                the exception that the chip select bits in the descriptors 
                are internally decoded and gated with the frame signal. 
                The DBSPI interface has no /FRAME output signal, just the 
                external chip select pins. These external active low pins 
                may be used directly as SPI device chip selects.
Bits 24..28   = Chip select delay = chip select valid delay before and 
                after frame in (N+1 CLOCKLOW periods, N = 0 ..15
                n>15 = 0 delay. Normally meaning-less for DBSPI - set to >15
Bit 29	      = Sample input data late. If this bit is set, slave output data
                is sampled 1/2 clock cycle late. This is useful for higher 
                clock rates, and for systems with large delays from 
                clock to slave data valid.            
Bit 30        = Dont_Clear_Frame. If set, leave frame asserted at EOT.
                This is for SPI devices that send or recv more than 32 bits 
                of data. for example a 48 bit SPI access can be built from 
                access via a descriptor setup for 32 bits and  
                Dont_Clear_Frame set, followed  by access via a descriptor 
                setup for 16 bit access with Dont_Clear_Frame cleared.	
Bit 31 	      = Dont_Echo. If set, dont push SPI returned data on
                receive FIFO. (for output only SPI devices) 

0x5900	DBSPI FIFOCount register 0
0x5940	DBSPI FIFOCount register 1
0x5980	DBSPI FIFOCount register 2
0x59C0	DBSPI FIFOCount register 3
  
FIFOCount:

Bits 0..4     = Receve FIFO data counter
Bits 8..12    = Transmit FIFO data counter

If FIFO count register is written (data is dont care), both FIFOs will be 
cleared



Smart Serial Module: Up to 15 channels of high speed UARTs with 33-50 mips
embedded processor for buried protocol applications. Default 2K of 
program ROM and 512 bytes of RAM

SSERIAL Processor command register

This is for access to the smart serial modules parameters, allows reading and 
writing parameter. Parameter access is just for setup and discovery,
not realtime.

Firmware is host side downloadable so neither bitfile recompilation nor 
Xilinx blockram loading tools are required to try new firmware.

Bit 15	    Write bit          1 for writes, 0 for reads	     	    
Bit 14	    Reset bit          Proc/firmware download bit
Bit 13	    Request bit	       Must be set for parameter read or write
Bit 12	    DoIt bit	       Set to start data transfer cycle with remotes 
Bit 11	    Start/Stop bit     Set to indicate firmware start/stop command	       
Bits 10..0  Parameter address for read/write commands  
                        

0x5A00	 SSERIAL 0 Processor command register 
0x5A40	 SSERIAL 1 Processor command register 
...


0x5B00	 8 bit Processor data register
This is for access to the smart serial modules parameters, allows reading and 
writing parameters. Parameter access is just for setup and discovery, 
not realtime.

0x5B00	 SSERIAL 0 8 bit Processor data register
0x5B40	 SSERIAL 1 8 bit Processor data register
...

SSERIAL 32 bit realtime registers

The command status register is used for writing requests and reading 
back status, it has a host-uProc doorbell for each channel so the 
SSerial processor in notified of host writes

0x5C00 	   SSERIAL 0 channel 0 command/status register
0x5C04 	   SSERIAL 0 channel 1 command/status register
0x5C08 	   SSERIAL 0 channel 2 command/status register
0x5C0C 	   SSERIAL 0 channel 3 command/status register
... 

0x5C40 	   SSERIAL 1 channel 0 command/status register
0x5C44 	   SSERIAL 1 channel 1 command/status register
0x5C48 	   SSERIAL 1 channel 2 command/status register
0x5C4C 	   SSERIAL 1 channel 3 command/status register


0x5D00 	   SSERIAL 0 channel 0 user interface register 0 
0x5D04 	   SSERIAL 0 channel 1 user interface register 0 
0x5D08 	   SSERIAL 0 channel 2 user interface register 0 
0x5D0C 	   SSERIAL 0 channel 3 user interface register 0 
... 

0x5D40 	   SSERIAL 1 channel 0 user interface register 0 
0x5D44 	   SSERIAL 1 channel 1 user interface register 0 
0x5D48 	   SSERIAL 1 channel 2 user interface register 0 
0x5D4C 	   SSERIAL 1 channel 3 user interface register 0 


0x5E00 	   SSERIAL 0 channel 0 user interface register 1 
0x5E04 	   SSERIAL 0 channel 1 user interface register 1 
0x5E08 	   SSERIAL 0 channel 2 user interface register 1 
0x5E0C 	   SSERIAL 0 channel 3 user interface register 1 
... 

0x5E40 	   SSERIAL 1 channel 0 user interface register 1 
0x5E44 	   SSERIAL 1 channel 1 user interface register 1 
0x5E48 	   SSERIAL 1 channel 2 user interface register 1 
0x5E4C 	   SSERIAL 1 channel 3 user interface register 1 
...

0x5F00 	   SSERIAL 0 channel 0 user interface register 2 
0x5F04 	   SSERIAL 0 channel 1 user interface register 2 
0x5F08 	   SSERIAL 0 channel 2 user interface register 2 
0x5F0C 	   SSERIAL 0 channel 3 user interface register 2 
... 

0x5F40 	   SSERIAL 1 channel 0 user interface register 2 
0x5F44 	   SSERIAL 1 channel 1 user interface register 2 
0x5F48 	   SSERIAL 1 channel 2 user interface register 2 
0x5F4C 	   SSERIAL 1 channel 3 user interface register 2 



UART TX data register
Different offsets push different numbers of bytes on xmit FIFO
Didn't use byte enables for compatibility with other (non PCI) 
32 bit interfaces

0x6000 UART 0 TXdata (push 1 byte)
0x6004 UART 0 TXData (push 2 bytes)
0x6008 UART 0 TXData (push 3 bytes)
0x600C UART 0 TXData (push 4 bytes)
0x6010 UART 1 TXdata (push 1 byte)
0x6014 UART 1 TXData (push 2 bytes)
0x6018 UART 1 TXData (push 3 bytes)
0x601C UART 1 TXData (push 4 bytes)
0x6020 UART 2 TXdata (push 1 byte)
0x6024 UART 2 TXData (push 2 bytes)
0x6028 UART 2 TXData (push 3 bytes)
0x602C UART 2 TXData (push 4 bytes)
0x6030 UART 3 TXdata (push 1 byte)
0x6034 UART 3 TXData (push 2 bytes)
0x6038 UART 3 TXData (push 3 bytes)
0x603C UART 3 TXData (push 4 bytes)
...

UART TX FIFO count register = number slots used in FIFO, 
pushes less than one 32 bit word use a hole word slot, in other words, 
TX FIFO is 16 32 bit words deep, but 16 one byte pushes will fill the FIFO, 
so TX FIFO capacity is 16 Bytes for byte pushes, but 64 bytes with 
16 doubleword pushes.
Writes to the FIFO count register clear the FIFO.

0x6100 UART 0 TXFIFO Count
0x6110 UART 1 TXFIFO Count
0x6120 UART 2 TXFIFO Count
0x6130 UART 3 TXFIFO Count
...

TX Bitrate select register. TX bitrate is generated by a 20 bit 
phase accumulator. Bitrate is: (TXBitrate_Register_Value/1048576)*ClockLow

0x6200 UART 0 TX Bitrate Register
0x6210 UART 1 TX Bitrate Register
0x6220 UART 2 TX Bitrate Register
0x6230 UART 3 TX Bitrate Register
...

UART TX mode register controls TXEnable and TXEnable timing (for half duplex)

Bit 0..3 = TXEnable delay. TXEnable delay specifies the transmit data 
        holdoff time from the TXenable signal valid state. This is used 
        for RS-485 
        (half duplex) operaton, to delay transmit data until the driver 
        is enabled, allowing for driver enable delays, isolation barrier 
        delays etc. Delay is in units of ClockLow period.
Bit 4 = FIFOError, it indicates that a host push has overflowed the FIFO
        (Mainly for driver debugging)
Bit 5 = DriveEnableAuto, When set, enables Drive when any data is in FIFO or 
        Xmit Shift register,removes drive when FIFO and Xmit shift register 
        are empty.
Bit 6 = DriveEnableBit, If DriveEnableAuto is 0, controls Drive (
        for software control of Xmit drive)

0x6300 UART 0 TX Mode register
0x6310 UART 1 TX Mode register
0x6320 UART 2 TX Mode register
0x6330 UART 3 TX Mode register
...

UART RX Data register, Different offsets pop different numbers of bytes 
from RX FIFO, data is always right justified. FIFO depth is 16 bytes. 
I may eventually change this to use byte enables.

0x6400 UART 0 RX Data (POP 1 byte)
0x6404 UART 0 RX Data (POP 2 bytes)
0x6408 UART 0 RX Data (POP 3 bytes)
0x640C UART 0 RX Data (POP 4 bytes)
0x6410 UART 1 RX Data (POP 1 byte)
0x6414 UART 1 RX Data (POP 2 bytes)
0x6418 UART 1 RX Data (POP 3 bytes)
0x641C UART 1 RX Data (POP 4 bytes)
0x6420 UART 2 RX Data (POP 1 byte)
0x6424 UART 2 RX Data (POP 2 bytes)
0x6428 UART 2 RX Data (POP 3 bytes)
0x642C UART 2 RX Data (POP 4 bytes)
0x6430 UART 3 RX Data (POP 1 byte)
0x6434 UART 3 RX Data (POP 2 bytes)
0x6438 UART 3 RX Data (POP 3 bytes)
0x643C UART 3 RX Data (POP 4 bytes)
...

UART RX FIFO count register = number of bytes in RX FIFO 
(5 bits right justified, other bits are undefined)
Writes to the RX FIFO count register clear RX FIFO

0x6500 UART 0 RXFIFO Count
0x6510 UART 1 RXFIFO Count
0x6520 UART 2 RXFIFO Count
0x6530 UART 3 RXFIFO Count
...

UART RX Bitrate select register. RX bitrate is generated by a 20 bit 
phase accumulator. 
Bitrate is (RXBitrate_Register_Value/1048576)*ClockLow

0x6600 UART 0 RX Bitrate Register 
0x6610 UART 1 RX Bitrate Register 


0x6620 UART 0 RX Bitrate Register 0
0x6630 UART 1 RX Bitrate Register
...

RX MODE/STATUS Register

Bit 0 = FalseStart bit Status, 1 = false start bit detected
Bit 1 = OverRun Status, 1 = overrun condition detected (no valid stop bit)
Bit 2 = RXMaskEnable, 1= enable RXMask for half duplex operation, 
        0 = ignore RXMask
Bit 4 = FIFOError, indicates that a host read has attemped to read more 
        data than available. (mainly for driver debugging)
Bit 5 = LostDataError, indicates that data was received with no room in FIFO, 
        therefore lost
Bit 6 = RXMask, RO RXMASK status
Bit 7 = FIFO Has Data

0x6700 UART 0 RX Mode/Status register
0x6710 UART 1 RX Mode/Status register
0x6720 UART 2 RX Mode/Status register
0x6730 UART 3 RX Mode/Status register
...


Notes:
1. RXMaskEnable uses the transmitters TXEN as a mask to the character receive 
   logic. This is so that when 2 wire RS-485 type interfaces are used, the 
   transmit data ia not echoed back to the receiver

*******************************************************************

Packet UARTX
Packet UARTs are designed simplify interfacing to packet mode remote devices
that use gaps in the data stream for framing. These are standard asynchronous
UARTs that have provisions for sending data in packets with interpacket gaps

PktUARTx data register (write only)

Send data is pushed (32 bits at a time) to this address. 
Data bytes in a 32 bit word  are transmitted LS byte first
and all packets start sending the LS byte of the 32 bit word
(data in adjacent packets is _not_ packed)

0x6000	  PktUARTx 0 data register	
0x6004	  PktUARTx 1 data register	
0x6008	  PktUARTx 2 data register	
0x600c	  PktUARTx 3 data register	
0x6010	  PktUARTx 4 data register	

...

PktUARTx  send count register read/write

The send count register is written with the number of bytes to send
after tha data has been pushed to the PktUARTx data register. 
writing the send count register starts the transmission process.
Send counts are written to 16 deep FIFO allowing up to 16 packets to be 
sent in a burst (subject to data FIFO depth limits). Reads of the send 
count register return the remaining packets to be sent.

0x6100	PktUARTx 0 send count register
0x6104	PktUARTx 1 send count register
0x6108	PktUARTx 2 send count register
0x610C	PktUARTx 3 send count register

PktUARTx bit rate register

The bit rate register set the transmit bit rate. 
The bit rate is set with a 20 bit DDS, bit rate is 
(register value/1048576)*ClockLow 

0x6200	PktUARTx 0 bit rate register
0x6204	PktUARTx 1 bit rate register
0x6208	PktUARTx 2 bit rate register
0x630C	PktUARTx 3 bit rate register


PktUARTx mode register

The PktUARTxMode register is used for setting and checking the
PktUARTx's operation mode, timing and status

Bit  21	       FrameBuffer Has Data
Bits 20..16    Frames to send
Bits 15..8     InterFrame delay in bit times
Bit  7	       Buffer error (send idle but data in send data FIFO) read only
Bit  6	       Drive Enable bit (enables external RS-422/485 Driver when set)
Bit  5	       Drive enable Auto (Automatic external drive enable)
Bit  4	       unused
Bits 3..0      Drive enable delay (delay from asserting drive enable 
     	       to start of data transmit. In CLock Low periods  


0x6300  PktUARTx 0 mode register
0x6304  PktUARTx 1 mode register
0x6308  PktUARTx 2 mode register
0x630C  PktUARTx 3 mode register

The PktUARTx mode register has a special data command that clears the PktUARTx
Clearing aborts any sends in process, clears the data FIFO and 
clears the send count FIFO. To issue a clear command, you write 0x80010000
to the PktUARTx mode register.


Example: send 10 bytes of data 
(data sent is 0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A)

write 0x04030201 to PktUARTx data register
write 0x08070605 to PktUARTx data register
write 0x00000A09 to PktUARTx data register  (note right justify)

Note that the number of 32 bit writes to the PktUARTx data register
will always be rounded up to full 32 bit words 
(Bytes_Sent + 3) div 4

write 0x0000000A to PktUARTx sendcount register



PktUARTr data register (read only)

Receive data is popped (32 bits at a time) from this address. 
Data bytes in a 32 bit word  are received LS byte first
and all receive packets begin in the LS byte of the 32 bit word
(data in adjacent packets tha are not multiples of 4 bytes
are _not_ packed)

0x6400	  PktUARTr 0 data register	
0x6404	  PktUARTr 1 data register	
0x6408	  PktUARTr 2 data register	
0x640c	  PktUARTr 3 data register	
0x6010	  PktUARTr 4 data register	

...

PktUARTr  receive count register read only

The receive count register is a FIFO that contains the byte counts 
of recieved packets. Since it is a FIFO it must only be read once after it 
has be determined that there are packets available to read.
Bits 31..16	  Unused
Bit 15 		  Overrun error in this packet
Bit 14 		  False Start bit error in this packet

Bits 9..0	  bytes in receive packet  


0x6500  PktUARTr 0 receive count register
0x6504	PktUARTr 1 receive count register
0x6508	PktUARTr 2 recieve count register
0x650C	PktUARTr 3 receive count register

PktUARTx bit rate register

The bit rate register set the receive bit rate. 
The bit rate is set with a 20 bit DDS, bit rate is 
(register value/1048576)*ClockLow 

0x6600	PktUARTr 0 bit rate register
0x6604	PktUARTr 1 bit rate register
0x6608	PktUARTr 2 bit rate register
0x660C	PktUARTr 3 bit rate register


PktUARTr mode register

The PktUARTrMode register is used for setting and checking the PktUARTr's 
operation mode, timing, and status
Bit  21	       FrameBuffer has data	
Bits 20..16    Frames received
Bits 15..8     InterFrame delay in bit times
Bit  7	       Buffer error (RX idle but data in RX data FIFO) read only
Bit  6	       RXMask
Bit  5         Unused
Bit  4	       RCFIFO Error
Bit  3	       RXEnable (must be set to receive packets) 
Bit  2	       RXMask Enable (enables input data masking when transmitting)
Bit  1	       Overrun error (no stop bit when expected) (sticky)
Bit  0	       False Start bit error (sticky)

0x6700  PktUARTr 0 mode register
0x6704  PktUARTr 1 mode register
0x6708  PktUARTr 2 mode register
0x670C  PktUARTr 3 mode register

The PktUARTx mode register has a special data command that clears the PktUARTr
Clearing aborts any receives in process, clears the data FIFO and 
clears the receive count FIFO. To issue a clear command, you write 0x80010000
to the PktUARTr mode register.

The RX interframe delay is always set shorter than the TX interframe delay
to guarantee proper framing detection. LBP16 sets the RX interframe delay 
to 2 character times (20 bit times) and the TX interframe delay to 4 character 
times (40 bit times)

Example receive a packet with 7 bytes (0x01,0x02,0x03,0x04,0x05,0x06,0x07)

First poll the mode register for a non zero frames recieved count 
(mode register bits 20..16). Then read the receive byte count of 
the first packet from the receive count FIFO  and mask the lower 10 bits to
get the receive packet byte count) then read the 7 bytes of packet 
data from the PktUARTr data register:

Read PktUARTr data reg --> 0x04030201
Read PktUARTr data reg --> 0xXX070605

Note that the number of 32 bit reads from the PktUARTr 
data register will always be rounded up to full 32 bit words 
(Bytes_Received + 3) div 4 


***********************************************************************

Simple SSI interface:

This is a simple SSI interface for absolute encoders

SSI Data Register0, right justifed. Writes to this location will start a
read cycle for the specific SSI interface addressed 

0x6800 SSI data register0 channel 0
0x6804 SSI data register0 channel 1
0x6808 SSI data register0 channel 2
0x680C SSI data register0 channel 3
...

0x6900 SSI data register1 channel 0
0x6904 SSI data register1 channel 1
0x6908 SSI data register1 channel 2
0x690C SSI data register1 channel 3
...

SSIControlRegister: Set to number of SSI encoder bits and SSI rate
In addition to the SSI bit count, ans SSI rate, the control register has 
3 additional control and status bits:

Bit 0..5 =  SSI bit count
Bit 8    =  Program Start Mask   If set, writes to SSIGlobalStart start a cycle
Bit 9    =  Timer Start Mask     If set, rate generator edge starts a cycle 
...
Bit 11   =                       Busy Status, R/O, set at beginning of cycle
                                 cleared at end of cycle
Bits 12..14			 Timer channel select
Bit 15				 Data Available register, set by transfer complete, 
    				 cleared by reading data register 0
Bits 16..31			 Sets shift frequency for SSI interface

The timer select register selects the desired timer output
from the DPLL timer module: 0=Ref 1=timer1, 2=timer2, 3=timer3, 4=timer4
The TStartMask must be set to enable timer starts.

Shift rate is set via a 16 bit DDS. Shift frequency is 
(CLockLow*SSIBitRate)/65536 For example with a 48 MHz clock 
(4I68,5I22,5I23), A register value of 546 gives a ~400KHz shift clock

0x6A00 SSI control register 0
0x6A04 SSI control register 1
0x6A08 SSI control register 2
0x6A0C SSI control register 3
...

 
SSI Global Start/Busy register. Writes to this address start all SSI interfaces
that have their Program Start Mask bit set.

Reading the Global start register returns the busy status of each channel, 
with bit# = channel# A channel is busy if the transfer is in progress or 
the data is stale (its already been read)  

0x6B00 SSI global start register (for all SSI interfaces)


Notes:

For common clock applications (using one clock to drive multiple 
SSI channels), all SSI channels using the common clock must be programmed 
identically. That is, all bit count registers and bit rate registers of 
SSI interfaces with common clocks must have the same values.



DAQFIFO

DAQFIFO is a simple data aquisition FIFO. Currently its external interface 
is 16 bits wide. The Host side FIFO is 32 bits wide so two 16 bit pushes are 
needed to push a full word onto the FIFO. If an odd number of pushes is 
recieved, the host can push the "remainder" by writing to the FIFO

DAQFIFO data register, reads read FIFO data, writes push odd word

0x6C00  DAQFIFO 0 data port 	  
0x6C40  DAQFIFO 1 data port	   	  
0x6C80  DAQFIFO 2 data port 	  
0x6CC0  DAQFIFO 3 data port 	  
 
DAQFIFO count register, reads read FIFO count, writes clear FIFO count and 
even/odd input flipflop

Bit 0..15 = FIFO count
Bit 24 = odd word waiting

0x6D00  DAQFIFO 0 FIFO count 	  
0x6D40  DAQFIFO 1 FIFO count 	  
0x6D80  DAQFIFO 2 FIFO count 	  
0x6DC0  DAQFIFO 3 FIFO count 	  


DAQFIFO mode/status register

Bit 0 = Strobe polarity, 0 for active low , 1 for active high
Bit 1 = Underflow status, 0 normal, 1 indicates a host read from empty FIFO
Bit 2 = Overflow status, 0 normal, 1 indicates a external push with a full FIFO
Bit 3 = DRQ/IRQ status, 0 = no request, 1 = active request
Bits 16..31 = request threshold set to 0 for software access, some 
              larger number for DMA or interrupt service routine access

0x6E00  DAQFIFO 0 mode/status register
0x6E40  DAQFIFO 1 mode/status register
0x6E80  DAQFIFO 2 mode/status register
0x6Ec0  DAQFIFO 3 mode/status register

HM2DPLL

This is a simple DPLL for generating timing events between periodic accesses.
It can be useful for starting read cycles on devices that have a significant 
aquisition time (SPI,SSI encoders, Fanuc serial pulsecoders etc). It also can be 
used to remove jitter from read  and write cycles, if the module hardware allows
latching read data on timer events or updating output latches on timing events
4 timers with a resolution of access period/65536 are available.

HM2DPLL registers:

DPLL base rate = (clocklow/2^DDSSize*DPLLPreScale)*BaseRateRegisterValue
 
0x7000	32 bit HM2DPLL BaseRate

0x7100 DPLLPhaseError

32 bit phase error, writes load the accumulator


0x7200 DPLLControlRegister0

Bits 0..23	On writes = PLimit (phase adjustment limit)
     		On reads = Filtered Phase Error
Bits 24..31	DPLL Prescale
 

DPLLControlregister1
   
0x7300 DPLLControlregister1

Bits 0..7	(Read Only) DDSSize 
Bits 16..31	Filter Time constant

0x7400 DPLLTimer12

Bits 0..15	Timer1 phase 
Bits 16..31	Timer2 phase 

0x7500 DPLLTimer34

Bits 0..15	Timer3 phase 
Bits 16..31	Timer4 phase

Timer phase is advance from reference (sync) access time
range is 0 to 65535/65536 DPLL period advance

0x7600	DPLLSync

Read or writes here phase lock the DPLL to the host software periodic access.
Write data is dont care, reads return phase error. If interpreted as a 
signed number, Phase error is positive for late access and negative for 
early access. Actual time error is (Phase_Error/2^32)*DPLL period.

 

Address Translation RAM 
The address translation RAM is used to eliminate expensive address cycles 
when addressing hardwired sequences of non-contiguous bytes.
This is useful for EPP devices to eliminate address cycles
and for PCI devices to allow slaves to be accessed with burst transfers.
It also allows PCI DMA to group all reads and all writes into sigle operations

The address RAM give indirect access to all internal registers.

Translation RAM, 256 deep by 16 bit wide address translation RAM

0x7800	Translation RAM byte address 0 
0x7804    Translation RAM byte address 1
...
0x7BFC	Translation RAM byte address 255

Data in translation RAM is LS 16 bits (MS 16 bits are unused) 
of 32 bit word.
For EPP and USB (byte wide) devices, Bit 15 is StrobeBit. 
For PCI devices, the strobe bit is unused.
For read sequences, the StrobeBit must be 
OR'ed with the first translation RAM address entry of a read sequence, 
for write sequences, the StrobeBit must be OR'ed with the last 
translation  RAM address of the write sequence.

To use address translation, there is a 256 byte window where addresses are 
translated:

7C00	Translation region byte 0 (controlled by Trans RAM address @ 0x7800
7C01	Translation region byte 1 (controlled by Trans RAM address @ 0x7804
...
7CFF	Translation region byte 255 (controlled by Trans RAM address @ 0x7BFC


Here is an example of using address translation (With EPP) to write one 24 bit 
I/O port, read the next 24 bit I/O port and read and 4 quadrature counters, 
skipping the timestamp, and update 4 PWM generators.

First initialize the translation RAM (Only done once at program startup)

write32 0x7800 0x1000	First byte of port write
write32 0x7804 0x1001	Second byte of port write
write32 0x7808 0x9002	Third byte of port write (Note: OR'ed with StrobeBit)
write32 0x780C 0x9004	First byte of read (Note OR'ed with StrobeBit)
write32 0x7810 0x1005	Second byte of read
write32 0x7814 0x1006	Third byte of read
write32 0x7818 0xB000	First byte of Qcounter0 (Note: OR'ed with StrobeBit)
write32 0x781C 0x3001	Second byte of Qcounter0
write32 0x7820 0xB004	First byte of Qcounter1 (Note: OR'ed with StrobeBit)
write32 0x7824 0x3005	Second byte of Qcounter1
write32 0x7828 0xB008	First byte of Qcounter2 (Note: OR'ed with StrobeBit)
write32 0x782C 0x3009	Second byte of Qcounter2
write32 0x7830 0xB00C	First byte of Qcounter3 (Note: OR'ed with StrobeBit)
write32 0x7834 0x300D	Second byte of Qcounter3
write32 0x7838 0x4002	First byte of PWMGen0 (in MS word)
write32 0x783C 0xC003	Second byte of PWMGen0  (Note: OR'ed with StrobeBit)
write32 0x7838 0x4004	First byte of PWMGen1 (in MS word)
write32 0x783C 0xC005	Second byte of PWMGen1  (Note: OR'ed with StrobeBit)
write32 0x7838 0x4008	First byte of PWMGen2 (in MS word)
write32 0x783C 0xC009	Second byte of PWMGen2  (Note: OR'ed with StrobeBit)
write32 0x7838 0x400C	First byte of PWMGen3 (in MS word)
write32 0x783C 0xC00D	Second byte of PWMGen3  (Note: OR'ed with StrobeBit)

Once these 22 address translation table entries are initialized, 
the following sequence of EPP operations will do all the data transfers:

writeaddr 	0x00
writeaddr 	0xFC	This sets up the 16 bit EPP address as 0xFC00 
			= translation region (0x7C00) with auto-inc (0x8000)

writedata	write port 0 Byte 0
writedata	write port 0 Byte 1
writedata	write port 0 Byte 2
readdata	read Port 1 byte 0	 
readdata	read Port 1 byte 1
readdata	read Port 1 byte 2
readdata	read Qcounter 0 byte 0
readdata	read Qcounter 0 byte 1
readdata	read Qcounter 1 byte 0
readdata	read Qcounter 1 byte 1
readdata	read Qcounter 2 byte 0
readdata	read Qcounter 2 byte 1
readdata	read Qcounter 3 byte 0
readdata	read Qcounter 3 byte 1
writedata	write PWMVal 0 byte 0
writedata	write PWMVal 0 byte 1
writedata	write PWMVal 1 byte 0
writedata	write PWMVal 1 byte 1
writedata	write PWMVal 2 byte 0
writedata	write PWMVal 2 byte 1
writedata	write PWMVal 3 byte 0
writedata	write PWMVal 3 byte 1

Notes: For compatibility reasons, basic register access is still 32 bits 
even with address translation, so a 32 bit write is always done even if 
only a single byte is written. This is usually not important, but does 
have some subtle side effects. For example if a 24 bit wide I/O 
port is defined with 16 input bits and 8 output bits (say to interface 
with a 7I37), the 8 output bits can be updated in a single byte write 
thats part of a sequence in the translation RAM. The side effect of this 
is that the 16 unused output bits that coorespond to the input bits on 
the port _will_ be written with random data.
