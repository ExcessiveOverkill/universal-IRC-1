HostMot2 Register map in offsets from 32 bit memory base address
Note the following addresses are standard but driver should use IDROM info
instead of this table as some configurations may not be mapped the same.

Also, number of special functions (counters, PWMGens etc) is determined 
by configuration.
Additional registers are always at increasing doubleword boundaries 
with the exception of UART data FIFOs , SSerial data registers,
BSPI data FIFOs, and ResMod position and velocity registers 


First ID stuff

0x0100	Config cookie 	= 0x55AACAFE
0x0104	First 4 characters of configuration name
0x0108	Last 4 characters of configuration name
0x010C	Offset to IDROM location (normally 0x00000400)

LEDS

0x0200	LEDS are in MS bits (left justified)

Then the IDROM

0x0400	Normal IDROM location

0x400	IDROMType		3 for this type
0x404	OffsetToModules		64 for this type
0x408	OffsetToPindesc		384 for this type
0x40C	BoardNameLow		
0x410	BoardNameHigh
0x414	FPGA size
0x418	FPGA pins
0x41C	IOPorts			
0x420	IOWidth
0x424	PortWidth		
0x428	ClockLow		In Hz	(note:on 5I20/4I65 = PCI clock 
                                guessed as 33.33 MHz)
0x42C	ClockHigh		In Hz
0x430	InstanceStride0		Stride between register instances (option 0)
0x434	InstanceStride1		Stride between register instances (option 1)
0x438	RegisterStride0         Stride between different registers (option 0) 
0x43C	RegisterStride1		Stride between different registers (option 1)

Instance stride is address step to next register of same type but next channel
For example PWMGen(0) to PWMGen(1)
Register stride is address step to next register in functional group. 
for example IOPort(0) to DDR(0)

0x440..	Module descriptions 0 through 31
Each module descriptor is three doublewords with the following record structure:

0x440: (from least to most significant order)
GTag(0		(byte) = General function tag
Version(0)	(byte) = module version
ClockTag(0)	(byte) = Whether module uses ClockHigh or ClockLow
Instances(0)	(byte) = Number of instances of module in configuration
BaseAddress(0)	(word) = offset to module. This is also specific register = Tag
Registers(0)	(byte) = Number of registers per module
Strides(0)	(byte) = Specifies which strides to use
MPBitmap(0)	(Double) = bit map of which registers are multiple 
                '1' = multiple, LSb = reg(0)

0x44C: (from least to most significant order)
GTag(1)		(byte) = General function tag
Version(1)	(byte) = module version
ClockTag(1)	(byte) = Whether module uses ClockHigh or ClockLow
Instances(1)	(byte) = Number of instances of module in configuration
BaseAddress(1)	(word) = offset to module. This is also specific register = Tag
Registers(1)	(byte) = Number of registers per module
Strides(1)	(byte) = Specifies which strides to use
MPBitmap(1)	(Double) = bit map of which registers are multiple 
                '1' = multiple, LSb = reg(0)


0 GTag marks end of module descriptors (note Rev 2 IDROMS MDs start at 0x600)


0x5C0 Pin descriptors 0 through 143. 
There is one Pin Descriptor for each I/O pin.
Each pin descriptor is a doubleword with the following record structure:

0x5C0: (from least to most significant order)
SecPin(0)	(byte) = Which pin of secondary function connects here 
                eg: A,B,IDX. 
                         Output pins have bit 7 = '1'
SecTag(0)	(byte) = Secondary function type (PWM,QCTR etc). 
                Same as module GTag
SecUnit(0)	(byte) = Which secondary unit or channel connects here
PrimaryTag(0)	(byte) = Primary function tag (normally I/O port)

0x5C4:(from least to most significant order)
SecPin(1)	(byte) = Which pin of secondary function connects here 
                eg: A,B,IDX. 
                         Output pins have bit 7 = '1'
SecTag(1)	(byte) = Secondary function type (PWM,QCTR etc). 
                Same as module GTag
SecUnit(1)	(byte) = Which secondary unit or channel connects here
PrimaryTag(1)	(byte) = Primary function tag (normally I/O port)

...



0x0800  1 bit IDROM write enable bit: high=Enable writes

0x0900	IRQDiv 

16 bit divider of selected PWM reference output bit. Divides by n+2.

0x0A00	IRQStatus

Bit 2..4  Select which PWM reference counter bit is used as IRQ divider source:
000 = PWMRefcount(MSb-7)
001 = PWMRefcount(MSb-6)
010 = PWMRefcount(MSb-5)
011 = PWMRefcount(MSb-4)
100 = PWMRefcount(MSb-3)
101 = PWMRefcount(MSb-2)
110 = PWMRefcount(MSb-1)
111 = PWMRefcount(MSb)

Bit 1 = Irq mask: 0 = masked

Bit 0 = IRQ status (R/W)

0x0B00	ClearIRQ: Writes here clear IRQ 


0x0C00	WatchdogTimer (R/W

32 bit watchdog timer.If MSb is set, watchdog is disabled.
Timeout is WatchdogTimer+1/CLKLOW. Currently all watchdog does 
is clear GPIO DDR, and OpenDrain registers setting all GPIO to 
inputs (high with pullups)

0x0D00	WatchDogStatus

Bit 0 = Watchdog has bitten status (1 = you been bit)

0x0E00

Watchdog Cookie location

0x5A written to 8 MSbs will reset watchdog to previously written 
timeout value.


Demand mode DMA logic

Bit 0 = Enable Demand mode DMA
Bit 1 = DRQ status, - = active request
Bits 16..31 = DRQ mask for demand mode DMA modules 0..15

Note this should be reset to 0x00000000 to enable re-configuration
on 4I68, 5I23, 5I22, and 3X20 as DREQ/DACK are muxed with /PROGRAM and DONE 
 
0x0F00 = DemandMode DMA enable register
	    

0x1000	I/O port  0..23
0x1004  I/O port 24..47
0x1008  I/O port 48..71
0x100C  I/O port 72..95
0x1010  I/O port 96..127
0x1014  I/O port 128..143

Writes write to output register, reads read pin status

0x1100	DDR for I/O port  0..23
0x1104  DDR for I/O port  24..47
0x1108  DDR for I/O port  48..71
0x110C  DDR for I/O port  72..95
0x1110  DDR for I/O port  96..127
0x1114  DDR for I/O port  128..144

'1' bit in DDR register makes corresponding GPIO bit an output

0x1200  AltSourceReg for I/O port  0..23
0x1204  AltSourceReg for I/O port  24..47
0x1208  AltSourceReg for I/O port  48..71
0x120C  AltSourceReg for I/O port  72..95
0x1210  AltSourceReg for I/O port  96..127
0x1214  AltSourceReg for I/O port  128..143


'1' bit in AltSource register makes corresponding GPIO bit data source 
come from Alternate source for that bit instead of GPIO output register.

0x1300	OpenDrainSelect for I/O port  0..23
0x1304  OpenDrainSelect for I/O port  24..47
0x1308  OpenDrainSelect for I/O port  48..71
0x130C  OpenDrainSelect for I/O port  72..95
0x1310  OpenDrainSelect for I/O port  96..127
0x1314  OpenDrainSelect for I/O port  128..143


'1' bit in OpenDrainSelect register makes corresponding GPIO an 
open drain output.
If OpenDrain is selected for an I/O bit , the DDR register is ignored.

0x1400	OutputInvert for I/O port  0..23
0x1404  OutputInvert for I/O port  24..47
0x1408  OutputInvert for I/O port  48..71
0x140C  OutputInvert for I/O port  72..95
0x1410  OutputInvert for I/O port  96..127
0x1414  OutputInvert for I/O port  128..143

A '1' bit in the OutputInv register inverts the cooresponding output bit.
This may be the GPIO output register bit or alternate source. The input is 
not inverted.

**************************************************
Fanuc absolute encoder interface. Interfaces to Fanuc serial absolute encoders

DataReg0

0x1500 32 bit serial data 0..31 for FAbs channel 0
0x1504 32 bit serial data 0..31 for FAbs channel 1
0x1508 32 bit serial data 0..31 for FAbs channel 2

Writing to DataReg0 starts a transfer request on the selected
FanucAbs module

...
DataReg1

0x1600 32 bit serial data 32..63 for FAbs channel 0
0x1604 32 bit serial data 32..63 for FAbs channel 1
0x1608 32 bit serial data 32..63 for FAbs channel 2
...
DataReg2

0x1700 12 bit serial data 64..75 for FAbs channel 0 (right justified)
0x1704 12 bit serial data 64..75 for FAbs channel 1 (right justified)
0x1708 12 bit serial data 64..75 for FAbs channel 2 (right justified)
...
DataReg 2 is also used for optional setup bits and a cable error status bit
Bit 31	CableErr     (R/O) If this bit is set, it indicates that the data 
                     polarity is wrong or the cable is unplugged
Bits 24..30	     Bit Length ((default 76) only writeable 
     		     if write setup enable bit is set
Bit 14..23	     Request length register, default 8 Usec. only writeable
    		     if write setup enable bit is set

Request length is request length register value * clocklow period


Data
Note: Fanuc serial encoder data is LSb first so is right shifted, 
and ends up left justified in the three data registers

0x1800 Control register 0 for FAbs channel 0
0x1804 Control register 0 for FAbs channel 1
0x1808 Control register 0 for FAbs channel 2
...

Control register 0 fields:

Bit 15		 Data Available set by transfer done, cleared by reading data 0 register
Bit 12..14	 Timer channel select
Bit 11		 Busy bit, set when transfer is started, 
   		 cleared when all data bits are recieved 
Bit 10		 RXGo set when recieve data start bit is detected
    		 cleared when all data bits are received     
Bit 9		 TStartMask, if set, timer start transfer is allowed
Bit 8		 GstartMask, if set global start transfer is allowed
Bit 7		 Setup Write Enable register


The timer select register selects the desired timer output
from the DPLL timer module: 0=Ref 1=timer1, 2=timer2, 3=timer3, 4=timer4
The TStartMask must be set to enable timer starts. 

0x1900 Control register 1 for FAbs channel 0
0x1904 Control register 1 for FAbs channel 1
0x1908 Control register 1 for FAbs channel 2
...

Control register 1
Bits 0..19	 Bitrate select register. (default set for 1.024 MHz bit rate)
     		 Only writeable if write setup enable bit is set
Bits 28..31	 Digital filter setting in clock low counts (default  0xF)
    		 Only writeble if write setup enable bit is set

Note a digital filter value of 0 will not work (only 1..15 are valid)

Receive bitrate is generated by a 20 bit phase accumulator. 
Bitrate is: (Control_Register_1/1048576)*ClockLow
re-arranged this is Control_Register_1 = 1048576*Bitrate/ClockLow

0x1A00 Global start register/busy register. Writing the global start register
(data is dont-care) starts transfers on all FanucAbs modules that have their 
global start mask set. 

Reading the Global start register returns the busy status of each channel, 
with bit# = channel# A channel is busy if the transfer is in progress or 
the data is stale (its already been read)  

Fanuc data format (76 bits): So far just for Aa64 (860-360-xxx)
bits 0..4 	constant : encoder type?
bit  5     	1=battery fail
bits 6,7	unknown
bit  8		1=un-indexed
bits 9..17	unknown, perhaps for higher res encoders
bits 18..33	16 bit absolute encoder data (0..65535 for one turn)
bits 34..35      unknown
bits 36..51	16 bit absolute turns count
bits 52,53	unknown
bits 54..63	10 bit absolute commutation encoder (four 0.1023 cycles per turn)
bits 64..70	unknown
bits 71..75	ITU CRC-5 (calculated MSB first)

These encoders are absolute if the battery backup is maintained since the 
last homing. This can be determined by the status of the un-indexed bit, 
at least until the encoder crosses index. Surprisingly 
(well it surprised me anyway) the encoders maintain position with battery 
power alone. It appears that they keep the LEDS/processor alive with a 
few uA of battery power (probably low duty cycle LED pulsing/analog circuits 
power cycling). This can be verified by reading the battery current and then 
moving the encoder, it goes from a few uA to many mA with a slow encoder move.

The commutation track is always absolute so can be used for commutation 
data regardless of the index status. Note that the commutation track
seems to be interpolated so is not better than maybe 1% accuracy
 
Note that the timing/baudrate are all precalculated so should not need
changing, but can be changed by setting the setup enable bit in control reg 0

**************************************************
Step/dir generators currently 48 bit accumulator = 16 bits full step, 
32 fractional step/rate. That is a 48 bit accumulator with a 32 bit rate 
value (sign extended) and added to accumulator.

 Step rate registers : Write only

0x2000	32 bit rate register for StepGen 0 
0x2004 	32 bit rate register for StepGen 1  
0x2008	32 bit rate register for StepGen 2
0x200C	32 bit rate register for StepGen 3
0x2010	32 bit rate register for StepGen 4
0x2014	32 bit rate register for StepGen 5
0x2018	32 bit rate register for StepGen 6
0x201C	32 bit rate register for StepGen 7
...

 32 bit top of accumulator = 16.16 fullstep.fractionalstep : Read/write

0x2100	32 bit full.fractional accum for StepGen 0
0x2104 	32 bit full.fractional accum for StepGen 1  
0x2108	32 bit full.fractional accum for StepGen 2
0x210C	32 bit full.fractional accum for StepGen 3
0x2110	32 bit full.fractional accum for StepGen 4
0x2114	32 bit full.fractional accum for StepGen 5
0x2118	32 bit full.fractional accum for StepGen 6
0x211C	32 bit full.fractional accum for StepGen 7
...

Mode registers (Non index versions: 2 bits Write only)
00 = Step/Dir
01 = Up/Down
10 = Quadrature
11 = Table Driven

0x2200	2 bit mode register for StepGen 0
0x2204 	2 bit mode register for StepGen 1  
0x2208	2 bit mode register for StepGen 2
0x220C	2 bit mode register for StepGen 3
0x2210	2 bit mode register for StepGen 4
0x2214	2 bit mode register for StepGen 5
0x2218	2 bit mode register for StepGen 6
0x221C	2 bit mode register for StepGen 7
...

Mode registers (Stepgen verions with index) 
Bits 1,0:
00 = Step/Dir
01 = Up/Down
10 = Quadrature
11 = Table Driven

Bit 2 = Swap outputs (swap step/dir outputs if 1)
Bit 3 Not used currently
Bit 4 Latch-on-index (latch current step accumulator on index, cleared by index occurance)
Bit 5 Index polarity
Bit 6 Latch-on-Probe (latch current step accumulator on probe, cleared by probe occurance) 
Bit 7 Probe polarity

Bits 31..8 = Latched accumulator data (MS 24 bits), latched by index or probe occurance

0x2200	32 bit mode register for StepGen 0
0x2204 	32 bit mode register for StepGen 1  
0x2208	32 bit mode register for StepGen 2
0x220C	32 bit mode register for StepGen 3
0x2210	32 bit mode register for StepGen 4
0x2214	32 bit mode register for StepGen 5
0x2218	32 bit mode register for StepGen 6
0x221C	32 bit mode register for StepGen 7
...     

DIR Setup time = how long DIR must be valid before step 
pulses may be issued.
Max time for 14 bits at ClockLow = 33 MHz = ~480 uS. 
At ClockLow = 50 MHz = ~320 uS (dont use 0)

Write only

0x2300	14 bit DIR setup time register for StepGen 0
0x2304 	14 bit DIR setup time register for StepGen 1  
0x2308	14 bit DIR setup time register for StepGen 2
0x230C	14 bit DIR setup time register for StepGen 3
0x2310	14 bit DIR setup time register for StepGen 4
0x2314	14 bit DIR setup time register for StepGen 5
0x2318	14 bit DIR setup time register for StepGen 6
0x231C	14 bit DIR setup time register for StepGen 7
...

DIR Hold time = how long DIR most remain valid after 
a step pulse has been issued. 
Max time for 14 bits at ClockLow = 33 MHz = ~480 uS. 
At ClockLow = 50 MHz = ~320 uS (dont use 0)

Write only

0x2400	14 bit DIR hold time register for StepGen 0
0x2404 	14 bit DIR hold time register for StepGen 1  
0x2408	14 bit DIR hold time register for StepGen 2
0x240C	14 bit DIR hold time register for StepGen 3
0x2410	14 bit DIR hold time register for StepGen 4
0x2414	14 bit DIR hold time register for StepGen 5
0x2418	14 bit DIR hold time register for StepGen 6
0x241C	14 bit DIR hold time register for StepGen 7
...

Pulse length = Active time of output pulse (N+1 clocks).
Max time for 14 bits at ClockLow = 33 MHz = ~480 uS. 
At ClockLow = 50 MHz = ~320 uS (dont use 0)

Write only

0x2500	14 bit pulse width register for StepGen 0
0x2504 	14 bit pulse width register for StepGen 1  
0x2508	14 bit pulse width register for StepGen 2
0x250C	14 bit pulse width register for StepGen 3
0x2510	14 bit pulse width register for StepGen 4
0x2514	14 bit pulse width register for StepGen 5
0x2518	14 bit pulse width register for StepGen 6
0x251C	14 bit pulse width register for StepGen 7
...

Pulse Idle = Inactive time of output pulse (N+1 clocks).
Max time for 14 bits at ClockLow = 33 MHz = ~480 uS. 
At ClockLow = 50 MHz = ~320 uS 

Write only

0x2600	14 bit pulse idle width register for StepGen 0
0x2604 	14 bit pulse idle width register for StepGen 1  
0x2608	14 bit pulse idle width register for StepGen 2
0x260C	14 bit pulse idle width register for StepGen 3
0x2610	14 bit pulse idle width register for StepGen 4
0x2614	14 bit pulse idle width register for StepGen 5
0x2618	14 bit pulse idle width register for StepGen 6
0x261C	14 bit pulse idle width register for StepGen 7
...

Output sequence table. This is a single write location where the 
table sequence data for table driven step generator output is stored.
Data is written sequentially here from last to first data word in the 
sequence. Default table width is 6 bits.
Table data is in LSBs of written word.

0x2700	Table sequence data setup register for StepGen 0
0x2704	Table sequence data setup register for StepGen 1
0x2708	Table sequence data setup register for StepGen 2
0x270C	Table sequence data setup register for StepGen 3
0x2710	Table sequence data setup register for StepGen 4
0x2714	Table sequence data setup register for StepGen 5
0x2718	Table sequence data setup register for StepGen 6
0x271c	Table sequence data setup register for StepGen 7
...

TableLength register: 4 bit register that determines table sequence 
length. Sequence length is TableLength+1, Maximum length is 16 steps
Only used in table mode.

0x2800	Table sequence length register for StepGen 0
0x2804	Table sequence length register for StepGen 1
0x2808	Table sequence length register for StepGen 2
0x280C	Table sequence length register for StepGen 3
0x2810	Table sequence length register for StepGen 4
0x2814	Table sequence length register for StepGen 5
0x2818	Table sequence length register for StepGen 6
0x281c	Table sequence length register for StepGen 7

...

0x2900  32 bit master DDS for all stepgens (compile time option,
may be disabled)


0x2A00  4 bit master timer select register for DPLL stepgen position sampling
        bit 15 down to 12 = Timer select bits 3 down to 0 
        Bits select timers 0 through 4 ( timer 4 is reference time ) 
        Any timer select > 4 disables timer based sampling

Step generator addition rate is (ClockLow*MasterDDSVal/2^32)

Probably just set to 0xffffffff for most applications.

WaveGen: simple table driven waveform generator

WaveGenRate

32 bit register, sets rate of steps through table = WaveGenRate/2^32*ClockHigh 

0x2B00 wavegen 0 rate
0x2B04 wavegen 1 rate
0x2B08 wavegen 2 rate
0x2B0C wavegen 3 rate
...

WaveGenPDMRate

8 bit register, sets PDM clock, PDM clock = ClockHigh/(WaveGenPDMRate+2)
any rate with MSB set will divide by one (0x80 or >)

0x2C00 wavegen 0 PDM rate
0x2C00 wavegen 1 PDM rate
0x2C00 wavegen 2 PDM rate
0x2C00 wavegen 3 PDM rate
...

WaveGenLength

10 bit register, sets table length (table pointer range is 0 --> WaveGenLength)

0x2D00 wavegen 0 table length 
0x2D04 wavegen 1 table length 
0x2D08 wavegen 2 table length 
0x2D0C wavegen 3 table length 
...

WaveGenTablePtr

10 bit register for host access to table pointer, writes to table 
must first write address pointer, and the write data.

0x2E00 wavegen 0 table pointer
0x2E04 wavegen 1 table pointer
0x2E08 wavegen 2 table pointer
0x2E0C wavegen 3 table pointer

...
 
16 bit register for host access to table data, writes to table 
must first write address pointer, and the write data.

0x2F00 wavegen 0 table data
0x2F04 wavegen 1 table data
0x2F08 wavegen 2 table data
0x2F0C wavegen 3 table data 

Table Data is 12 bit offset binary(2048 is '0") plus 4 trigger bits
trigger bits are top 4 bits of data

Bit 15    Trigger3         
Bit 14    Trigger2
Bit 13    Trigger1
Bit 12    Trigger0
Bit 11..0 Waveform data	


QuadratureCounter Type 2 (with timestamp)
32 bit register: bottom 16 bits are count, 
top 16 bits are timestamp of last count change
Writes to counter register clear the counter.

0x3000 quad counter 0	
0x3004 quad counter 1	
0x3008 quad counter 2	
0x300C quad counter 3	
0x3010 quad counter 4	
0x3014 quad counter 5	
0x3018 quad counter 6	
0x301c quad counter 7	
...

The time stamp allows reciprocal time (DeltaCount/DeltaTime) 
velocity calculation for better estimation of motor velocity 
at low counts/sample interval.


QuadratureCounter latch/Control register
32 bit register: top 16 bits are latched (by index) count, 
bottom 16 bits is control register.

0x3100 quad counter latch/CCR 0	
0x3104 quad counter latch/CCR 1	
0x3108 quad counter latch/CCR 2	
0x310C quad counter latch/CCR 3	
0x3110 quad counter latch/CCR 4	
0x3114 quad counter latch/CCR 5	
0x3118 quad counter latch/CCR 6	
0x311c quad counter latch/CCR 7	
...

Bit 31..16 = Latched count (Latch on index)

Bit 15	Quad Error: reads: set if quadrature sequence error, writes: set to clear Quad Error
Bit 14	AB mask polarity: A*B must be high for index gate
Bit 13	LatchOnProbe 1 = Latch count on probe (Version 3 counters only)
Bit 12	ProbePolarity 1 = active high         (Version 3 counters only)
Bit 11  Quad filter (0 = 3 clocks 1 = 15 clocks)
Bit 10	CounterMode 0 = Quadrature, 1 = up/down
Bit 9	UseIndexMask 1 = use mask
Bit 8	IndexMask Polarity 1=active high
Bit 7	ABgateIndex 1 = gate index signal with A,B
Bit 6	JustOnce 1 = ClearOnIndex, LatchOnIndex, LatchOnProbe happen only once
Bit 5	ClearOnIndex 1 = Clear count on index 
Bit 4	LatchOnIndex 1 = Latch count on index
Bit 3	IndexPol 1 = active high
Bit 2	read only realtime index signal
Bit 1	read only realtime B signal
Bit 0	read only realtime A signal

0x3200  TSSDiv 16 bit time stamp programmable divider (in LSBs) (R\W)

Sets quadrature counter reference clock for timestamp.

Timestamp count rate is ClockLow/(TSDiv+2). 
Any divisor with MSb set = divide by 1

0x3300  TSCount 16 bit time stamp counter (read only) 

0x3400  QfilterRate 12 bit Quadrature counter filter rate
count rate is ClockLow/(QFilterRate+2). 
Any divisor with MSb set = divide by 1

0x3500  DPLL timer select register

Bit 12  DPLL timer select bit 0
Bit 13  DPLL timer select bit 1
Bit 14  DPLL timer select bit 2
Bit 15  DPLL timer enable, if set encoder is sampled by DPLL timer,
if clear encoder count is sampled by host read

Bits 12..15 select DPLL timers 0..4 
Timer 0 is 0 offset, timers 1 through 4 have programmable offset
Timer selects >4 disable DPLL encoder sampling

MuxedQuadratureCounter Type 2 (with timestamp)
Note: Multiplexed counters have same register bits but differing
count rate limits than normal quadrature counters

32 bit register: bottom 16 bits are count, 
top 16 bits are timestamp of last change
Writes to counter register clear the counter.

0x3600 quad counter 0	
0x3604 quad counter 1	
0x3608 quad counter 2	
0x360C quad counter 3	
0x3610 quad counter 4	
0x3614 quad counter 5	
0x3618 quad counter 6	
0x361c quad counter 7	
...

The time stamp allows reciprocal time (DeltaCount/DeltaTime) 
velocity calculation for better estimation of motor velocity 
at low counts/sample interval

MuxedQuadratureCounter latch/Control register
32 bit register: top 16 bits are latched (by index) count, 
bottom 16 bits is control register

0x3700 quad counter latch/CCR 0	
0x3704 quad counter latch/CCR 1	
0x3708 quad counter latch/CCR 2	
0x370C quad counter latch/CCR 3	
0x3710 quad counter latch/CCR 4	
0x3714 quad counter latch/CCR 5	
0x3718 quad counter latch/CCR 6	
0x371c quad counter latch/CCR 7	
...

Bit 31..16 = Latched count (Latch on index)

Bit 15	Quad Error: reads: set if quadrature sequence error, writes: set to clear Quad Error
Bit 14	AB mask polarity: A*B must be high for index gate
Bit 13	LatchOnProbe 1 = Latch count on probe (Version 3 counters only)
Bit 12	ProbePolarity 1 = active high         (Version 3 counters only)
Bit 11  Quad filter (0 = 3 clocks 1 = 15 clocks)
Bit 10	CounterMode 0 = Quadrature, 1 = up/down
Bit 9	UseIndexMask 1 = use mask
Bit 8	IndexMask Polarity 1=active high
Bit 7	ABgateIndex 1 = gate index signal with A,B
Bit 6	JustOnce 1 = ClearOnIndex, LatchOnIndex, LatchOnProbe happen only once
Bit 5	ClearOnIndex 1 = Clear count on index 
Bit 4	LatchOnIndex 1 = Latch count on index
Bit 3	IndexPol 1 = active high
Bit 2	read only realtime index signal
Bit 1	read only realtime B signal
Bit 0	read only realtime A signal

0x3800  MuxedTSSDiv 16 bit time stamp programmable divider (in LSBs) (R\W)

Sets quadrature counter reference clock for timestamp.

MuxedTimestamp count rate is ClockLow/(MuxedTSDiv+2). 
Any divisor with MSb set = divide by 1

0x3900  MuxedTSCount 16 bit time stamp counter (read only) 

0x3A00  QfilterRate 12 bit Quadrature counter filter rate 
(bits 0 ..11) 
count rate is ClockLow/(QFilterRate+2). 
Any divisor with MSb (bit 11) set = divide by 1

0x3B00  DPLL timer select register

Bit 12 	DPLL timer select bit 0
Bit 13  DPLL timer select bit 1
Bit 14  DPLL timer select bit 2
Bit 15  DPLL timer enable, if set encoder is sampled by DPLL timer, 
if clear encoder count is sampled by host read

Bits 12..15 select DPLL timers 0..4 
Timer 0 is 0 offset, timers 1 through 4 have programmable offset

Version 4 and greater muxed encoders have 4 bit muxed data deskew register 
in top nibble (bits 28 ..31) of the QFilterRate register. 
This delays the sampling time of muxed encoder data by 0 to 15 ClockLow 
periods to accomodate long cables and isolation delays and allow higher 
multiplex rates. 

Notes about quadrature filter rate:

QFilterRate sets the sampling rate for all quadrature counters input filters.
Input filtering should be set with as long a time constant as possible, 
especially when using TTL encoders.

The time constant chosen should give a fair (say 30%) margin of quadrature 
counter maximum count rate above the hardwares maximum possible count rate.

For example with a 33MHz ClockLow and QfilterRate = 0xFFF (divide by one):

With the filter bit off, the the input filter requires 3 clocks to 
recognize an input change = ~90 nS. This gives a maximum input frequency 
of 1/180 nS = ~5MHz or a maximum quadrature (4X) count rate of ~ 16MHz 
(limited to 1/2 of 33 MHz) 

With the filter bit on, the the input filter requires 15 clocks to 
recognize an input change = ~450 nS. This gives a maximum input frequency 
of 1/900 nS = ~1.1MHz or a maximum quadrature (4X) count rate of ~ 4.4 MHz

This is still much faster than needed for most applications so the QFilterRate
register allows lowering the filter sample rate. For example with the 
Qfilterrate register set to divide by 10 (QFilterRate loaded with 8), 
the input filter sample rate at 33 MHz ClockLow would be 3.3 MHz:

With the filter bit off, the the input filter requires 3 clocks to 
recognize an input change = ~900 nS. This gives a maximum input frequency 
of 1/1800 nS = ~500 KHz or a maximum quadrature (4X) count rate of ~ 2MHz

With the filter bit on, the the input filter requires 15 clocks to 
recognize an input change = ~4500 nS. This gives a maximum input frequency 
of 1/9000 nS = ~110 KHz or a maximum quadrature (4X) count rate of ~ 440 KHz

440 KHz is adequate for most normal applications = 13200 RPM with a 500 line 
(2000 count) encoder, and has the benefit that noise rejection is very good, 
input noise pulses less than 4500 nS will be ignored. Most PWM generated 
noise pulses tend to be short, determined by the PWM voltage and the time 
constant of the PWM to encoder wire capacitance and the encoder output 
resistance. This output resistance is often quite high in low cost TTL 
encoders, with outputs that are just open collector comparators with pullup 
resistors. These encoders are very susceptible to low going noise pulses, and 
benefit greatly by maximizing the filter time constant.

Lowering the quadrature filter rate has the disadvantage of reducing the 
quadrature edge timing resolution when inverse time velocity estimation is 
used, however, this is normally not a problem as even at a 1 MHz sample rate, 
the 1 uSec timing uncertainty will be swamped out by the quadrature phase 
inaccuracies in typical encoders. 

For multiplexed quadrature counters, the multiplex channel rate is 1/2 the 
filter rate. Due to flat cable signal integrity and time of flight issues the 
multiplex channel rate should not be higher than 16 MHz, with lower rates 
needed with longer cable runs. This means that the filter rate should not 
be set higher than 16 MHz. The hardware default for the multiplexed flter 
rate register is set to divide by 4 which gives a multiplex rate of
4.166 MHz with a 33 MHz clklow and 6.25 MHz with a 50 MHZ clklow. 

Note that fixed clock skew can be adjusted to accomodate long cables and 
encoder isolation in muxed encoder version 4 and greater. This alo allow highermux rates
The hardware default filter rate is set to divide by 1 for non-multiplexed 
counters.


Resolver Module, 6 Channel resolver input module for 7I49 and 7I51 
daughter cards. Currently about 14-15 bit resolution, 10KHz, 5KHz and 2.5 KHz
selectable frequencies.

0x3C00	 Processor command register 
This is for access to the resolver modules parameters, normally not needed
except for debug and parameter tweaking or setting  resolver frequency

Bit 15	    Write bit
Bit 14	    Reset DSP/firmware download bit
Bit 13	    Do-it bit	 
Bits 11..0  Parameter address   

Firmware is host side downloadable so neither bitfile recompilation nor 
Xilinx blockram loading tools are required to try new firmware.

0x3D00	 32 bit Processor data register
This is for access to the resolver modules parameters, normally not needed
except for debug and parameter tweaking or setting resolver frequency

0x3E00  32 bit channel status register
The channel status register indicates the validity of the resolver data
Bits 5..0   Channel valid bits bit 0 - channel 0 valid etc


0x3F00    32 bit velocity 0
0x3F04    32 bit velocity 1
0x3F08    32 bit velocity 2
0x3F0C    32 bit velocity 3
0x3F10    32 bit velocity 4
0x3F14    32 bit velocity 5
0x3F18    32 bit unused
0x3F1C    32 bit unused
Resolver velocity readout, updated at resolver frequency. 
Units are 2^32 * resolver electrical rotations/resolver frequency


0x4000	  32 bit position 0
0x4004	  32 bit position 1
0x4008	  32 bit position 2
0x400C	  32 bit position 3
0x4010	  32 bit position 4
0x4014	  32 bit position 5
0x4018	  32 bit unused
0x401C	  32 bit unused

Resolver position readout, updated at 256*resolver frequency
Units are 2^32 * Resolver electrical rotations

PWM generators (With FPGA compile time constant PWM width = 13)

0x4100	PWMVal 0 Right justified 9..12 bit PWM in bits 27..16 DIR is bit 31
0x4104	PWMVal 1 Right justified 9..12 bit PWM in bits 27..16 DIR is bit 31
0x4108	PWMVal 2 Right justified 9..12 bit PWM in bits 27..16 DIR is bit 31
0x410C	PWMVal 3 Right justified 9..12 bit PWM in bits 27..16 DIR is bit 31
0x4110	PWMVal 4 Right justified 9..12 bit PWM in bits 27..16 DIR is bit 31
0x4114	PWMVal 5 Right justified 9..12 bit PWM in bits 27..16 DIR is bit 31
0x4118	PWMVal 6 Right justified 9..12 bit PWM in bits 27..16 DIR is bit 31
0x411C	PWMVal 7 Right justified 9..12 bit PWM in bits 27..16 DIR is bit 31
...
 	

PWM mode registers 6 bits

Bit 1,0 = width select  (With FPGA compile time constant PWM width = 13)
00 = 9 bit PWM
01 = 10 bit PWM
10 = 11 bit PWM
11 = 12 bit PWM

Bit 2 = PWM mode select
0 = Straight (Sawtooth) PWM     
1 = Symmetrical (Triangle) PWM

Bit 4,3 = PWM output mode select
00 = Normal Sign Magnitude PWM&DIR outputs normal
01 = Normal Sign Magnitude PWM&DIR outputs swapped (for locked antiphase)
10 = Up/down mode
11 = PDM mode (12 bits)

Bit 5 = Double Buffered mode
When bit 5 is set, the PWMval register is not updated until the beginning of a 
PWM cycle, avoiding extra transitions in the output PWM waveform. This adds 
an extra delay of 0 to PWMWidth/PWMClock (normal mode) or PWMWidth*2/PWMClock
(Symmetrical mode) between when the host writes the PWMVal register and the 
PWM output is updated. This mode should be used with HBridges. 


0x4200 PWM mode select register 0
0x4204 PWM mode select register 1
0x4208 PWM mode select register 2
0x420C PWM mode select register 3
0x4210 PWM mode select register 4
0x4214 PWM mode select register 5
0x4218 PWM mode select register 6
0x421C PWM mode select register 7
...

0x4300  16 bit PWM gen master rate DDS (PWMCLOCK = CLKHIGH*Rate/65536) 
        PWM rate will be PWMCLOCK/(2^PWMBITS) for normal PWM
        and PWMCLOCK/(2^(PWMBITS+1)) for symmetrical mode PWM.

0x4400	16 bit PDM gen master rate DDS (PDMCLOCK = CLKHIGH*Rate/65536) 
        PDM rate will be PDMCLOCK/(4096).

0x4500	Enable register for PWM. Doesn't actually change PWM but is used for 
        enabling PWM driven devices (the ENA pin). 1 bit per PWM channel. 
        Active high --> '1' means enabled = '0' output pin level.

Bit 0   PWM channel 0 enable
Bit 1   PWM channel 1 enable
Bit 2   PWM channel 2 enable

PWM/PDM Notes: 

1. For 7I33, 7I33T and 7I33TA that filter the PWM to generate analog voltages, 
   PDM mode should be used. Optimum PDM rate for best trade-off between ripple 
   and linearity for 7I33, 7I33T and 7I33TA is about 6 MHz 
   (PDM rate register approx 0x0fff) This gives about 13 bits of resolution 
   and 10 bit linearity/ripple.
   For 7I48 that uses up/down PWM mode, the highest 12 bit PWM frequency 
   should be used and the mode register set to 0x33 (12 bit, sawtooth, 
   up/down, double buffered)

2. Double buffering should be used where the PWM directly drives an HBridge. 
   Double buffering prevents extra transitions on the PWM output due to host 
   updates, which waste power in switching losses and could cause malfunction 
   on some HBridges. Double buffering should _not_ be used with PDM output! 
   Double Buffering will add a 0 to 1/PWMRate  delay in the PWM output if the
   host does not update the PWM generator synchronously with the PWM rate..


Three Phase PWM generator

0x4600 TPPWMVal 0 
0x4604 TPPWMVal 1 
0x4608 TPPWMVal 2 
0x460C TPPWMVal 3 
0x4610 TPPWMVal 4 
...

Bits 0..9    = 10 bit PWM value for PWMA
Bits 19..10  = 10 bit PWM value for PWMB
Bits 29..20  = 10 bit PWM value for PWMC

0x4700 TPPWM ENA REG 0
0x4704 TPPWM ENA REG 1
0x4708 TPPWM ENA REG 2
0x470C TPPWM ENA REG 3
0x4710 TPPWM ENA REG 4
...

Bit 0 =  Enable, Active high
Bit 1 =  Fault flag, active high

0x4800 TPPWM SETUP REG 0
0x4804 TPPWM SETUP REG 1
0x4808 TPPWM SETUP REG 2
0x480C TPPWM SETUP REG 3
0x4810 TPPWM SETUP REG 4
...

Bits 0..8 = Deadzone time in units of 2/TPWMCLK
Bit 15 =    Fault Input polarity 1 = fault on high, 0 = fault on low
Bits 16..26 = Sample time in units of TPWMCLK 

0x4900 TPPWM PWM RATE REGISTER

Bits 0..15 = 16 bit DDS that sets TPWMCLK, TPWMCLK = HSCLK*RATE/65536
TPPWM PWM rate will be TPWMCLK/2048

TPPWM Notes:

TPPWM provides gate drive signals for high and low sides of a 3 phase 
IGBT/MOSFET module. 

PWM mode is triangular so that ripple frequency is twice the PWM rate. 
TPPWM PWM output is always double buffered so that the PWM output values 
will only change synchronously with the PWM period. This means that the PWM 
update may be delayed from 0 to 1/(TPPPWM rate) after the host write.

The enable bit must be set to enable PWM outputs. The external enable signal 
follows the state of the internal enable bit. An active fault input clears the 
enable bit, sets the fault status bit and disables all PWM outputs. 
There is a ~70 nS noise filter on the fault input to prevent short glitches 
from triggering a fault. Fault is intended to connect to over current 
sense circuitry. 

The sample time register determines the time during the PWM cycle where a 
ADC sample pulse is generated, with a sample reg value of 1024 being the 
center of the PWM cycle, for SPI or other slow ADCs, the sample time can be 
moved earlier in the cycle to compensate for the sampletime to ADC aquisition 
time delays. 

Deadtime is in units of 2/TPWMCLK. Deadtime is subtracted from on time and 
added to off time symmetrically. For example with 20 KHz PWM (50 uSec period),
50% duty cycle and zero dead time, the PWM and NPWM outputs would be square 
waves (NPWM being inverted from PWM) with high times of 25 uS. With the same 
settings but 1 uS of deadtime, the PWM and NPWM outputs would both have high 
times of 23 uS (25 - (2X 1 uS), 1 uS per edge) 


BISS encoder module. Unidirectional BISS interface, 512 bits maximum

BISS Data register

0x4A00 BISS 0 32 bit data register
0x4A04 BISS 1 32 bit data register
0x4A08 BISS 2 32 bit data register
...

This register is the top of a 16 deep x32 wide LIFO stack. 
BISS data sizes greater that 32 bits are read by muliple reads 
of the same address. Data is returned LSW first and right justified. 
Writes to the data register start a data transfer in selected channel

BISS Control register 0
0x4B00 BISS 0 Control register
0x4B04 BISS 0 Control register
0x4B08 BISS 0 Control register
...

Bits 31..16	BISS DDS data rate register
Bits 15..10	BISS data digital filter setting in units of ClockHigh
Bits  9..0	BISS data bits (1 to 512)


The BISS data rate field sets the BISS clock rate. This rate is 
(Clock/65536)*BISS_DataRateReg

BISS Control register 1
0x4C00
0x4C04
0x4C08
...

Bit 15		SyncDAV status (read only)
Bits 14..12	DPLL Timer select register
Bit 10		RGo status (read only) 		
Bit  9          TStartMask
Bit  8  	PStartMask
Bits 4..0	words of Data to read (Read Only)


The timer select register selects the desired timer output 
from the DPLL timer module: 0=Ref 1=timer1, 2=timer2, 3=timer3, 4=timer4
The TStartMask must be set to enable timer starts. The PStartMask 
must be set to enable global starts.

BISS Global start register/busy status register
0x4D00	    Writes to the global start register start data transfers in all
	    BISS module that have the PStartMask set
	    Reads here read back the busy status of each BISS module
	    bit 0 high = module 0 busy, bit 1 high = module 1 busy etc


Twiddler Module: Smart GPIO bit twiddler, 1 to 31 bits of GPIO 
(input, output, or I/O) default 1K program ROM, 512 bytes of RAM
internal hardware includes free running timer, (preset to 10 MHz)
buffered I/O (update or sample all I/O at once) 8 bit 33 or 50 mips
processor, doorbell registers to indicate host parameter write, 


0x4E00	 Processor command register 
This is for access to the smart twiddler modules parameters, allows reading 
and writing parameters. Parameter access is just for setup and discovery.
not realtime.

Bit 15	    Write bit
Bit 14	    Reset uProc/firmware download bit
Bit 13	    Do-it bit	 
Bits 11..0  Parameter address   

Firmware is host side downloadable so neither bitfile recompilation nor 
Xilinx blockram loading tools are required to try new firmware.

0x4F00	 8 bit Processor data register
This is for access to the twiddler modules parameters, normally not needed
except for debug and parameter tweaking.



0x5000 	   32 bit read/write embedded processor communication register 0
0x5004 	   32 bit read/write embedded processor communication register 1
0x5008 	   32 bit read/write embedded processor communication register 2
0x500C 	   32 bit read/write embedded processor communication register 3

Default is four 32 bit read/write host communication registers


Simple SPI inteface. The simple SPI interface is most suited for SPI devices
with only one logical unit per SPI interface (like single channel ADCs, DACs or 
SPI I/O ports)

SPI SREG 32 bits (for data less than 32 bits data is right justified)

Writes here load shift register and start frame transmission

0x5100 SPI SREG 0
0x5104 SPI SREG 1
0x5108 SPI SREG 2
0x510C SPI SREG 3
0x5110 SPI SREG 4
0x5114 SPI SREG 5
...

SPI bit count register

Bits 0..5 = bits per SPI frame (bits = N+1) ie 0x1f = 32 bit frame
Bit 6 = CPOL = Clock polarity ( FreeScale SPI spec compatible definitions)
Bit 7 = CPHA = Clock Phase
Bit 8 = DontClearFrame = Dont clear frame at EOT (for transfers > 32 bits)
Bit 31 = DAV = data ready
Bit 30 = Busy

0x5200 SPI bit count register 0
0x5204 SPI bit count register 1
0x5208 SPI bit count register 2
0x520C SPI bit count register 3
0x5210 SPI bit count register 4
0x5214 SPI bit count register 5
...
SPI bit rate register

Bits 0..7 = programmable divider, SPI bit rate is CLOCKLOW/((N+1)*2) 
Maximum rate (N=0) is 24 MHz (5I22 with 48 MHz clock) or 16.66 (5I20 with 
33MHz clock. Minmum rate (N=255) is 93.75 KHz (48 MHz clock) or 
~65 KHz (33 MHz clock)

0x5300 SPI bit rate register 0
0x5304 SPI bit rate register 1
0x5308 SPI bit rate register 2
0x530C SPI bit rate register 3
0x5310 SPI bit rate register 4
0x5314 SPI bit rate register 5
...


BinOsc utility

The Binonsc interface is a simple binary counter with outputs that drive the 
I/O pins. BinOsc only has one control register and one bit in the register 
(enable)

0x5400

Bit 0	Enable		counter is cleared if 0 and free runs if 1


Buffered SPI interface (BSPI)

The buffered SPI interface is a FIFO buffered SPI interface 
that supports up to 16 devices on a single SPI port. Each device 
can have different bit lengths (up to 32 bits), different data rates, 
and a different code on the chip select bits. This information is 
stored in the channel descriptor for each SPI peripheral connected 
to a BSPI interface. The buffered SPI interface is most suited to use 
with SPI devices that have multiple channels per interface (multiple 
channel ADCs, DACs, or multiple devices sharing a SPI interface)
The transmit buffering allows the host to write multiple channel data 
without waiting for the SPI data transmission to complete. 
The receive buffering allows the host to gather all the received SPI 
data whenever convenient.

SPI interface data register

32 bits (for data less than 32 bits data is right justified)

0x5500 BSPI FIFO port 0
0x5540 BSPI FIFO port 1
0x5580 BSPI FIFO port 2
0x55C0 BSPI FIFO port 3
...
The SPI data FIFO is the location of a 16 deep transmit
and 16 deep receive FIFO for the SPI interface. There is only 
one transmit and one receive FIFO per buffered SPI interface
but the FIFO interface spans 16 doublewords of address space. 
This is so that when data is written to the FIFO, the address 
bits are written into the FIFO as well. These address bits select 
the channel descriptor at the SPI end of the transmit FIFO. 
The receive FIFO also spans the same address space but the 
read address within the range is dont-care.

0x5600 BSPI channel descriptor setup registor 0
0x5640 BSPI channel descriptor setup registor 1
0x5680 BSPI channel descriptor setup registor 2
0x56C0 BSPI channel descriptor setup registor 3
...

The channel descriptor setup location is where the channel 
descriptors for up to 16 SPI peripherals are written. The 
channel descriptors are written in last to first order, in 
other words, to setup  16 channel descriptors, first the 
channel descriptor for SPI device 15 is written, then the 
channel descriptor for SPI device 14 is written, repeating 
the decending device order until the channel descriptor for 
SPI device 0 is written.

ChannelDescriptor:

Bits 0..5    = bits per SPI frame (bits = N+1) ie 0x1f = 32 bit frame
Bit 6 = CPOL = Clock polarity ( FreeScale SPI spec compatible definitions)
Bit 7 = CPHA = Clock Phase
Bits 8..15   = Programmable divider, SPI bit rate is CLOCKLOW/((N+1)*2) 
               Maximum rate (N=0) is 24 MHz (5I22 with 48 MHz clock) or 16.66 
               (5I20 with 33MHz clock, Minmum rate (N=255) is 93.75 KHz 
               (48 MHz clock) or ~65 KHz (33 MHz clock)
Bits 16..19   = Chip select bits for SPI interface
     	      	The BSPI chip select bits are transfered directly to the
                chip select output pins. These normally used as addresses, 
                decoded and conditioned with the /FRAME signal externally. 
                This is for applications that need to minimize the number 
                of I/O pins.
Bits 24..28   = Chip select delay = chip select valid delay before and 
                after frame in (N+1 CLOCKLOW periods, N = 0 ..15
                n>15 = 0 delay.
Bit 30        = Dont_Clear_Frame. If set, leave frame asserted at EOT.
                This is for SPI devices that send or recv more than 32 bits 
                of data. for example a 48 bit SPI access can be built from 
                access via a descriptor setup for 32 bits and  
                Dont_Clear_Frame set, followed  by access via a descriptor 
                setup for 16 bit access with Dont_Clear_Frame cleared.	
Bit 31 	      = Dont_Echo. If set, dont push SPI returned data on
                receive FIFO. (for output only SPI devices) 

0x5700	BSPI FIFOCount register 0
0x5740	BSPI FIFOCount register 1
0x5780	BSPI FIFOCount register 2
0x57C0	BSPI FIFOCount register 3
  
FIFOCount:

Bits 0..4     = Receve FIFO data counter
Bits 8..12    = Transmit FIFO data counter

If FIFO count register is written (data is dont care), both FIFOs will be 
cleared


Decoded Buffered SPI interface (DBSPI) (same as BSPI but decoded outputs)

The SPI interface is a FIFO buffered SPI interface 
that supports up to 16 devices on a single SPI port. Each device 
can have different bit lengths (up to 32 bits), different data rates, 
and a different chip enabled on the chip select bits. This information is 
stored in the channel descriptor for each SPI peripheral connected 
to a DBSPI interface. 

SPI interface data register

32 bits (for data less than 32 bits data is right justified)

0x5800 DBSPI FIFO port 0
0x5840 DBSPI FIFO port 1
0x5880 DBSPI FIFO port 2
0x58C0 DBSPI FIFO port 3
...
The SPI data FIFO is the location of a 16 deep transmit
and 16 deep receive FIFO for the SPI interface. There is only 
one transmit and one receive FIFO per buffered SPI interface
but the FIFO interface spans 16 doublewords of address space. 
This is so that when data is written to the FIFO, the address 
bits are written into the FIFO as well. These address bits select 
the channel descriptor at the SPI end of the transmit FIFO. 
The receive FIFO also spans the same address space but the 
read address within the range is dont-care.

0x5900 DBSPI channel descriptor setup registor 0
0x5940 DBSPI channel descriptor setup registor 1
0x5980 DBSPI channel descriptor setup registor 2
0x59C0 DBSPI channel descriptor setup registor 3
...

The channel descriptor setup location is where the channel 
descriptors for up to 16 SPI peripherals are written. The 
channel descriptors are written in last to first order, in 
other words, to setup  16 channel descriptors, first the 
channel descriptor for SPI device 15 is written, then the 
channel descriptor for SPI device 14 is written, repeating 
the decending device order until the channel descriptor for 
SPI device 0 is written.

ChannelDescriptor:

Bits 0..5    = bits per SPI frame (bits = N+1) ie 0x1f = 32 bit frame
Bit 6 = CPOL = Clock polarity ( FreeScale SPI spec compatible definitions)
Bit 7 = CPHA = Clock Phase
Bits 8..15   = Programmable divider, SPI bit rate is CLOCKLOW/((N+1)*2) 
               Maximum rate (N=0) is 24 MHz (5I22 with 48 MHz clock) or 16.66 
               (5I20 with 33MHz clock, Minmum rate (N=255) is 93.75 KHz 
               (48 MHz clock) or ~65 KHz (33 MHz clock)
Bits 16..19   = Chip select bits for SPI interface
                The DBSPI interface is identical to the BSPI interface with 
                the exception that the chip select bits in the descriptors 
                are internally decoded and gated with the frame signal. 
                The DBSPI interface has no /FRAME output signal, just the 
                external chip select pins. These external active low pins 
                may be used directly as SPI device chip selects.
Bits 24..28   = Chip select delay = chip select valid delay before and 
                after frame in (N+1 CLOCKLOW periods, N = 0 ..15
                n>15 = 0 delay. Normally meaning-less for DBSPI - set to >15
Bit 29        = Sample Late. If set, sample the input 1/2 clock later 
                than nominal SPI sample time
Bit 30        = Dont_Clear_Frame. If set, leave frame asserted at EOT.
                This is for SPI devices that send or recv more than 32 bits 
                of data. for example a 48 bit SPI access can be built from 
                access via a descriptor setup for 32 bits and  
                Dont_Clear_Frame set, followed  by access via a descriptor 
                setup for 16 bit access with Dont_Clear_Frame cleared.	
Bit 31 	      = Dont_Echo. If set, dont push SPI returned data on
                receive FIFO. (for output only SPI devices) 

0x5A00	DBSPI FIFOCount register 0
0x5A40	DBSPI FIFOCount register 1
0x5A80	DBSPI FIFOCount register 2
0x5AC0	DBSPI FIFOCount register 3
  
FIFOCount:

Bits 0..4     = Receve FIFO data counter
Bits 8..12    = Transmit FIFO data counter

If FIFO count register is written (data is dont care), both FIFOs will be 
cleared



Smart Serial Module: Up to 15 channels of high speed UARTs with 33-50 mips
embedded processor for buried protocol applications. Default 2K of 
program ROM and 512 bytes of RAM

SSERIAL Processor command register

This is for access to the smart serial modules parameters, allows reading and 
writing parameter. Parameter access is just for setup and discovery,
not realtime.

Firmware is host side downloadable so neither bitfile recompilation nor 
Xilinx blockram loading tools are required to try new firmware.

Bit 15	    Write bit          1 for writes, 0 for reads	     	    
Bit 14	    Reset bit          Proc/firmware download bit
Bit 13	    Request bit	       Must be set for parameter read or write
Bit 12	    DoIt bit	       Set to start data transfer cycle with remotes 
Bit 11	    Start/Stop bit     Set to indicate firmware start/stop command	       
Bits 10..0  Parameter address for read/write commands  
                        

0x5B00	 SSERIAL 0 Processor command register 
0x5B40	 SSERIAL 1 Processor command register 
...


0x5C00	 8 bit Processor data register
This is for access to the smart serial modules parameters, allows reading and 
writing parameters. Parameter access is just for setup and discovery, 
not realtime.

0x5C00	 SSERIAL 0 8 bit Processor data register
0x5C40	 SSERIAL 1 8 bit Processor data register
...

SSERIAL 32 bit realtime registers

The command status register is used for writing requests and reading 
back status, it has a host-uProc doorbell for each channel so the 
SSerial processor in notified of host writes

0x5D00 	   SSERIAL 0 channel 0 command/status register
0x5D04 	   SSERIAL 0 channel 1 command/status register
0x5D08 	   SSERIAL 0 channel 2 command/status register
0x5D0C 	   SSERIAL 0 channel 3 command/status register
... 

0x5D40 	   SSERIAL 1 channel 0 command/status register
0x5D44 	   SSERIAL 1 channel 1 command/status register
0x5D48 	   SSERIAL 1 channel 2 command/status register
0x5D4C 	   SSERIAL 1 channel 3 command/status register


0x5E00 	   SSERIAL 0 channel 0 user interface register 0 
0x5E04 	   SSERIAL 0 channel 1 user interface register 0 
0x5E08 	   SSERIAL 0 channel 2 user interface register 0 
0x5E0C 	   SSERIAL 0 channel 3 user interface register 0 
... 

0x5E40 	   SSERIAL 1 channel 0 user interface register 0 
0x5E44 	   SSERIAL 1 channel 1 user interface register 0 
0x5E48 	   SSERIAL 1 channel 2 user interface register 0 
0x5E4C 	   SSERIAL 1 channel 3 user interface register 0 


0x5F00 	   SSERIAL 0 channel 0 user interface register 1 
0x5F04 	   SSERIAL 0 channel 1 user interface register 1 
0x5F08 	   SSERIAL 0 channel 2 user interface register 1 
0x5F0C 	   SSERIAL 0 channel 3 user interface register 1 
... 

0x5F40 	   SSERIAL 1 channel 0 user interface register 1 
0x5F44 	   SSERIAL 1 channel 1 user interface register 1 
0x5F48 	   SSERIAL 1 channel 2 user interface register 1 
0x5F4C 	   SSERIAL 1 channel 3 user interface register 1 
...

0x6000 	   SSERIAL 0 channel 0 user interface register 2 
0x6004 	   SSERIAL 0 channel 1 user interface register 2 
0x6008 	   SSERIAL 0 channel 2 user interface register 2 
0x600C 	   SSERIAL 0 channel 3 user interface register 2 
... 

0x6040 	   SSERIAL 1 channel 0 user interface register 2 
0x6044 	   SSERIAL 1 channel 1 user interface register 2 
0x6048 	   SSERIAL 1 channel 2 user interface register 2 
0x604C 	   SSERIAL 1 channel 3 user interface register 2 



UART TX data register
Different offsets push different numbers of bytes on xmit FIFO
Didn't use byte enables for compatibility with other (non PCI) 
32 bit interfaces

0x6100 UART TXdata 0 (push 1 byte)
0x6104 UART TXData 0 (push 2 bytes)
0x6108 UART TXData 0 (push 3 bytes)
0x610C UART TXData 0 (push 4 bytes)
0x6110 UART TXdata 1 (push 1 byte)
0x6114 UART TXData 1 (push 2 bytes)
0x6118 UART TXData 1 (push 3 bytes)
0x611C UART TXData 1 (push 4 bytes)
0x6120 UART TXdata 2 (push 1 byte)
0x6124 UART TXData 2 (push 2 bytes)
0x6128 UART TXData 2 (push 3 bytes)
0x612C UART TXData 2 (push 4 bytes)
0x6130 UART TXdata 3 (push 1 byte)
0x6134 UART TXData 3 (push 2 bytes)
0x6138 UART TXData 3 (push 3 bytes)
0x613C UART TXData 3 (push 4 bytes)
...

UART TX FIFO count register = number slots used in FIFO, 
pushes less than one 32 bit word use a hole word slot, in other words, 
TX FIFO is 16 32 bit words deep, but 16 one byte pushes will fill the FIFO, 
so TX FIFO capacity is 16 Bytes for byte pushes, but 64 bytes with 
16 doubleword pushes.
Writes to the FIFO count register clear the FIFO.

0x6200 UART TXFIFO Count 0
0x6210 UART TXFIFO Count 1
0x6220 UART TXFIFO Count 2
0x6230 UART TXFIFO Count 3
...

TX Bitrate select register. TX bitrate is generated by a 20 bit 
phase accumulator. Bitrate is: (TXBitrate_Register_Value/1048576)*ClockLow

0x6300 UART TX Bitrate Register 0
0x6310 UART TX Bitrate Register 1
0x6320 UART TX Bitrate Register 2
0x6330 UART TX Bitrate Register 3
...

UART TX mode register controls TXEnable and TXEnable timing (for half duplex)

Bit 0..3 = TXEnable delay. TXEnable delay specifies the transmit data 
        holdoff time from the TXenable signal valid state. This is used 
        for RS-485 
        (half duplex) operaton, to delay transmit data until the driver 
        is enabled, allowing for driver enable delays, isolation barrier 
        delays etc. Delay is in units of ClockLow period.
Bit 4 = FIFOError, it indicates that a host push has overflowed the FIFO
        (Mainly for driver debugging)
Bit 5 = DriveEnableAuto, When set, enables Drive when any data is in FIFO or 
        Xmit Shift register,removes drive when FIFO and Xmit shift register 
        are empty.
Bit 6 = DriveEnableBit, If DriveEnableAuto is 0, controls Drive (
        for software control of Xmit drive)

0x6400 UART TX Mode register 0
0x6410 UART TX Mode register 1
0x6420 UART TX Mode register 2
0x6430 UART TX Mode register 3
...

UART RX Data register, Different offsets pop different numbers of bytes 
from RX FIFO, data is always right justified. FIFO depth is 16 bytes. 
I may eventually change this to use byte enables.

0x6500 UART RX Data 0 (POP 1 byte)
0x6504 UART RX Data 0 (POP 2 bytes)
0x6508 UART RX Data 0 (POP 3 bytes)
0x650C UART RX Data 0 (POP 4 bytes)
0x6510 UART RX Data 1 (POP 1 byte)
0x6514 UART RX Data 1 (POP 2 bytes)
0x6518 UART RX Data 1 (POP 3 bytes)
0x651C UART RX Data 1 (POP 4 bytes)
0x6520 UART RX Data 2 (POP 1 byte)
0x6524 UART RX Data 2 (POP 2 bytes)
0x6528 UART RX Data 2 (POP 3 bytes)
0x652C UART RX Data 2 (POP 4 bytes)
0x6530 UART RX Data 3 (POP 1 byte)
0x6534 UART RX Data 3 (POP 2 bytes)
0x6538 UART RX Data 3 (POP 3 bytes)
0x653C UART RX Data 3 (POP 4 bytes)
...

UART RX FIFO count register = number of bytes in RX FIFO 
(5 bits right justified, other bits are undefined)
Writes to the RX FIFO count register clear RX FIFO

0x6600 UART RXFIFO Count 0
0x6610 UART RXFIFO Count 1
0x6620 UART RXFIFO Count 2
0x6630 UART RXFIFO Count 3
...

UART RX Bitrate select register. RX bitrate is generated by a 20 bit 
phase accumulator. 
Bitrate is (RXBitrate_Register_Value/1048576)*ClockLow

0x6700 UART RX Bitrate Register 0
0x6710 UART RX Bitrate Register 0
0x6720 UART RX Bitrate Register 0
0x6730 UART RX Bitrate Register 0
...

RX MODE/STATUS Register

Bit 0 = FalseStart bit Status, 1 = false start bit detected
Bit 1 = OverRun Status, 1 = overrun condition detected (no valid stop bit)
Bit 2 = RXMaskEnable, 1= enable RXMask for half duplex operation, 
        0 = ignore RXMask
Bit 4 = FIFOError, indicates that a host read has attemped to read more 
        data than available. (mainly for driver debugging)
Bit 5 = LostDataError, indicates that data was received with no room in FIFO, 
        therefore lost
Bit 6 = RXMask, RO RXMASK status
Bit 7 = FIFO Has Data

0x6800 UART RX Mode/Status register 0
0x6810 UART RX Mode/Status register 1
0x6820 UART RX Mode/Status register 2
0x6830 UART RX Mode/Status register 3
...


Notes:
1. RXMaskEnable uses the transmitters TXEN as a mask to the character receive 
   logic. This is so that when 2 wire RS-485 type interfaces are used, the 
   transmit data ia not echoed back to the receiver

****************************************************************************

Packet UARTX
Packet UARTs are designed simplify interfacing to packet mode remote devices
that use gaps in the data stream for framing. These are standard asynchronous
UARTs that have provisions for sending data in packets with interpacket gaps

PktUARTx data register (write only)

Send data is pushed (32 bits at a time) to this address. 
Data bytes in a 32 bit word  are transmitted LS byte first
and all packets start sending the LS byte of the 32 bit word
(data in adjacent packets is _not_ packed)

0x6100	  PktUARTx 0 data register	
0x6104	  PktUARTx 1 data register	
0x6108	  PktUARTx 2 data register	
0x610c	  PktUARTx 3 data register	
0x6110	  PktUARTx 4 data register	

...

PktUARTx  send count register read/write

The send count register is written with the number of bytes to send
after tha data has been pushed to the PktUARTx data register. 
writing the send count register starts the transmission process.
Send counts are written to 16 deep FIFO allowing up to 16 packets to be 
sent in a burst (subject to data FIFO depth limits). Reads of the send 
count register return the remaining packets to be sent.

0x6200	PktUARTx 0 send count register
0x6204	PktUARTx 1 send count register
0x6208	PktUARTx 2 send count register
0x620C	PktUARTx 3 send count register

PktUARTx bit rate register

The bit rate register set the transmit bit rate. 
The bit rate is set with a 20 bit DDS, bit rate is 
(register value/1048576)*ClockLow 

0x6300	PktUARTx 0 bit rate register
0x6304	PktUARTx 1 bit rate register
0x6308	PktUARTx 2 bit rate register
0x630C	PktUARTx 3 bit rate register


PktUARTx mode register

The PktUARTxMode register is used for setting and checking the
PktUARTx's operation mode, timing and status

Bit  21	       FrameBuffer Has Data RO
Bits 20..16    Frames to send  RO
Bit  17	       Parity enable WO
Bit  18	       Odd Parity  WO  (1=odd, 0=even)
Bits 15..8     InterFrame delay in bit times RW
Bit  7	       Send busy RO
Bit  6	       Drive Enable bit (enables external RS-422/485 Driver when set) RW
Bit  5	       Drive enable Auto (Automatic external drive enable) RW 
Drive Enable Auto has priority over Drive Enable (bit 6 is a no-op if bit 5 is set)
Bit  4	       SCFIFO Error RO
Bits 3..0      Drive enable delay (delay from asserting drive enable 
     	       to start of data transmit. In CLock Low periods RW 
Drive enable delay is important to avoid start bit timing errors 
at high baud rates in RS-485 (half duplex) modes

0x6400  PktUARTx 0 mode register
0x6404  PktUARTx 1 mode register
0x6408  PktUARTx 2 mode register
0x640C  PktUARTx 3 mode register

The PktUARTx mode register has a special data command that clears the PktUARTx
Clearing aborts any sends in process, clears the data FIFO and 
clears the send count FIFO. To issue a clear command, you write 0x80010000
to the PktUARTx mode register.


Example: send 10 bytes of data 
(data sent is 0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A)

write 0x04030201 to PktUARTx data register
write 0x08070605 to PktUARTx data register
write 0x00000A09 to PktUARTx data register  (note right justify)

Note that the number of 32 bit writes to the PktUARTx data register
will always be rounded up to full 32 bit words 
(Bytes_Sent + 3) div 4

write 0x0000000A to PktUARTx sendcount register



PktUARTr data register (read only)

Receive data is popped (32 bits at a time) from this address. 
Data bytes in a 32 bit word  are received LS byte first
and all receive packets begin in the LS byte of the 32 bit word
(data in adjacent packets tha are not multiples of 4 bytes
are _not_ packed)

0x6500	  PktUARTr 0 data register	
0x6504	  PktUARTr 1 data register	
0x6508	  PktUARTr 2 data register	
0x650c	  PktUARTr 3 data register	
0x6510	  PktUARTr 4 data register	

...

PktUARTr  receive count register read only

The receive count register is a FIFO that contains the byte counts 
of recieved packets. Since it is a FIFO it must only be read once after it 
has be determined that there are packets available to read.
Bits 31..16	  Unused
Bit 15 		  Overrun error in this packet
Bit 14 		  False Start bit error in this packet

Bits 9..0	  bytes in receive packet  


0x6600  PktUARTr 0 receive count register
0x6604	PktUARTr 1 receive count register
0x6608	PktUARTr 2 recieve count register
0x660C	PktUARTr 3 receive count register

PktUARTx bit rate register

The bit rate register set the receive bit rate. 
The bit rate is set with a 20 bit DDS, bit rate is 
(register value/1048576)*ClockLow 

0x6700	PktUARTr 0 bit rate register
0x6704	PktUARTr 1 bit rate register
0x6708	PktUARTr 2 bit rate register
0x670C	PktUARTr 3 bit rate register


PktUARTr mode register

The PktUARTrMode register is used for setting and checking the PktUARTr's 
operation mode, timing, and status
Bits 29..22    RX data digital filter (in ClockLow periods) 
               Should be set to 1/2 bit time 
               (or max=255 if it cannot be set long enough)
Bit  21	       FrameBuffer has data RO
Bits 20..16    Frames received RO
Bit  17        Parity enable WO
Bit  18        Odd Parity  WO  (1=odd, 0=even)
Bits 15..8     InterFrame delay in bit times RW
Bit  7	       Buffer error (RX idle but data in RX data FIFO) RO
Bit  6	       RXMask RO
Bit  5         Parity Error RW
Bit  4	       RCFIFO Error RW
Bit  3	       RXEnable (must be set to receive packets) RW 
Bit  2	       RXMask Enable (enables input data masking when transmitting) RW
Bit  1	       Overrun error (no stop bit when expected) (sticky) RW
Bit  0	       False Start bit error (sticky) RW

0x6800  PktUARTr 0 mode register
0x6804  PktUARTr 1 mode register
0x6808  PktUARTr 2 mode register
0x680C  PktUARTr 3 mode register

The PktUARTx mode register has a special data command that clears the PktUARTr
Clearing aborts any receives in process, clears the data FIFO and 
clears the receive count FIFO. To issue a clear command, you write 0x80010000
to the PktUARTr mode register.

The RX interframe delay is always set shorter than the TX interframe delay
to guarantee proper framing detection. LBP16 sets the RX interframe delay 
to 2 character times (20 bit times) and the TX interframe delay to 4 character 
times (40 bit times)

Example receive a packet with 7 bytes (0x01,0x02,0x03,0x04,0x05,0x06,0x07)

First poll the mode register for a non zero frames recieved count 
(mode register bits 20..16). Then read the receive byte count of 
the first packet from the receive count FIFO  and mask the lower 10 bits to
get the receive packet byte count) then read the 7 bytes of packet 
data from the PktUARTr data register:

Read PktUARTr data reg --> 0x04030201
Read PktUARTr data reg --> 0xXX070605

Note that the number of 32 bit reads from the PktUARTr 
data register will always be rounded up to full 32 bit words 
(Bytes_Received + 3) div 4 



Simple SSI interface:

This is a simple SSI interface for absolute encoders

SSI Data Register0, right justifed. Writes to this location will start a
read cycle for the specific SSI interface addressed 

0x6900 SSI data register0 channel 0
0x6904 SSI data register0 channel 1
0x6908 SSI data register0 channel 2
0x690C SSI data register0 channel 3
...

0x6A00 SSI data register1 channel 0
0x6A04 SSI data register1 channel 1
0x6A08 SSI data register1 channel 2
0x6A0C SSI data register1 channel 3
...

SSIControlRegister: Set to number of SSI encoder bits and SSI rate
In addition to the SSI bit count, ans SSI rate, the control register has 
3 additional control and status bits:

Bit 0..5 =  SSI bit count
Bit 8    =  Program Start Mask   If set, writes to SSIGlobalStart start a cycle
Bit 9    =  Timer Start Mask     If set, rate generator edge starts a cycle 
...
Bit 11   =                       Busy Status, R/O, set at beginning of cycle
                                 cleared at end of cycle
Bits 12..14			 Timer channel select
Bit 15				 Data Available register, set by transfer complete, 
    				 cleared by reading data register 0
Bits 16..31			 Sets shift frequency for SSI interface

The timer select register selects the desired timer output
from the DPLL timer module: 0=Ref 1=timer1, 2=timer2, 3=timer3, 4=timer4
The TStartMask must be set to enable timer starts.

Shift rate is set via a 16 bit DDS. Shift frequency is 
(CLockLow*SSIBitRate)/65536 For example with a 48 MHz clock 
(4I68,5I22,5I23), A register value of 546 gives a ~400KHz shift clock

0x6B00 SSI control register 0
0x6B04 SSI control register 1
0x6B08 SSI control register 2
0x6B0C SSI control register 3
...

 
SSI Global Start/Busy register. Writes to this address start all SSI interfaces
that have their Program Start Mask bit set.

Reading the Global start register returns the busy status of each channel, 
with bit# = channel# A channel is busy if the transfer is in progress or 
the data is stale (its already been read)  

0x6C00 SSI global start register (for all SSI interfaces)


Notes:

For common clock applications (using one clock to drive multiple 
SSI channels), all SSI channels using the common clock must be programmed 
identically. That is, all bit count registers and bit rate registers of 
SSI interfaces with common clocks must have the same values.



DAQFIFO

DAQFIFO is a simple data aquisition FIFO. Currently its external interface 
is 16 bits wide. The Host side FIFO is 32 bits wide so two 16 bit pushes are 
needed to push a full word onto the FIFO. If an odd number of pushes is 
recieved, the host can push the "remainder" by writing to the FIFO

DAQFIFO data register, reads read FIFO data, writes push odd word

0x6D00  DAQFIFO 0 data port 	  
0x6D40  DAQFIFO 1 data port	   	  
0x6D80  DAQFIFO 2 data port 	  
0x6DC0  DAQFIFO 3 data port 	  
 
DAQFIFO count register, reads read FIFO count, writes clear FIFO count and 
even/odd input flipflop

Bit 0..15 = FIFO count
Bit 24 = odd word waiting

0x6E00  DAQFIFO 0 FIFO count 	  
0x6E40  DAQFIFO 1 FIFO count 	  
0x6E80  DAQFIFO 2 FIFO count 	  
0x6EC0  DAQFIFO 3 FIFO count 	  


DAQFIFO mode/status register

Bit 0 = Strobe polarity, 0 for active low , 1 for active high
Bit 1 = Underflow status, 0 normal, 1 indicates a host read from empty FIFO
Bit 2 = Overflow status, 0 normal, 1 indicates a external push with a full FIFO
Bit 3 = DRQ/IRQ status, 0 = no request, 1 = active request
Bits 16..31 = request threshold set to 0 for software access, some 
              larger number for DMA or interrupt service routine access

0x6F00  DAQFIFO 0 mode/status register
0x6F40  DAQFIFO 1 mode/status register
0x6F80  DAQFIFO 2 mode/status register
0x6FC0  DAQFIFO 3 mode/status register

HM2DPLL

This is a simple DPLL for generating timing events between periodic accesses.
It can be useful for starting read cycles on devices that have a significant 
aquisition time (SPI,SSI encoders, Fanuc serial pulsecoders etc). It also can be 
used to remove jitter from read  and write cycles, if the module hardware allows
latching read data on timer events or updating output latches on timing events
4 timers with a resolution of access period/65536 are available.

HM2DPLL registers:

DPLL base rate = (clocklow/2^DDSSize*DPLLPreScale)*BaseRateRegisterValue
 
0x7000	32 bit HM2DPLL BaseRate

0x7100 DPLLPhaseError

32 bit phase error, writes load the accumulator


0x7200 DPLLControlRegister0

Bits 0..23	On writes = PLimit (phase adjustment limit)
     		On reads = Filtered Phase Error
Bits 24..31	DPLL Prescale
 

DPLLControlregister1
   
0x7300 DPLLControlregister1

Bits 0..7	(Read Only) DDSSize 
Bits 16..31	Filter Time constant

0x7400 DPLLTimer12

Bits 0..15	Timer1 phase 
Bits 16..31	Timer2 phase 

0x7500 DPLLTimer34

Bits 0..15	Timer3 phase 
Bits 16..31	Timer4 phase

Timer phase is advance from reference (sync) access time
range is 0 to 65535/65536 DPLL period advance

0x7600	DPLLSync

Read or writes here phase lock the DPLL to the host software periodic access.
Write data is dont care, reads return phase error. If interpreted as a 
signed number, Phase error is positive for late access and negative for 
early access. Actual time error is (Phase_Error/2^32)*DPLL period.

 

Address Translation RAM 
The address translation RAM is used to eliminate expensive address cycles 
when addressing hardwired sequences of non-contiguous bytes.
This is useful for EPP devices to eliminate address cycles
and for PCI devices to allow slaves to be accessed with burst transfers.
It also allows PCI DMA to group all reads and all writes into sigle operations

The address RAM give indirect access to all internal registers.

Translation RAM, 256 deep by 16 bit wide address translation RAM

0x7800	Translation RAM byte address 0 
0x7804    Translation RAM byte address 1
...
0x7BFC	Translation RAM byte address 255

Data in translation RAM is LS 16 bits (MS 16 bits are unused) 
of 32 bit word.
For EPP and USB (byte wide) devices, Bit 15 is StrobeBit. 
For PCI devices, the strobe bit is unused.
For read sequences, the StrobeBit must be 
OR'ed with the first translation RAM address entry of a read sequence, 
for write sequences, the StrobeBit must be OR'ed with the last 
translation  RAM address of the write sequence.

To use address translation, there is a 256 byte window where addresses are 
translated:

7C00	Translation region byte 0 (controlled by Trans RAM address @ 0x7800
7C01	Translation region byte 1 (controlled by Trans RAM address @ 0x7804
...
7CFF	Translation region byte 255 (controlled by Trans RAM address @ 0x7BFC


Here is an example of using address translation (With EPP) to write one 24 bit 
I/O port, read the next 24 bit I/O port and read and 4 quadrature counters, 
skipping the timestamp, and update 4 PWM generators.

First initialize the translation RAM (Only done once at program startup)

write32 0x7800 0x1000	First byte of port write
write32 0x7804 0x1001	Second byte of port write
write32 0x7808 0x9002	Third byte of port write (Note: OR'ed with StrobeBit)
write32 0x780C 0x9004	First byte of read (Note OR'ed with StrobeBit)
write32 0x7810 0x1005	Second byte of read
write32 0x7814 0x1006	Third byte of read
write32 0x7818 0xB000	First byte of Qcounter0 (Note: OR'ed with StrobeBit)
write32 0x781C 0x3001	Second byte of Qcounter0
write32 0x7820 0xB004	First byte of Qcounter1 (Note: OR'ed with StrobeBit)
write32 0x7824 0x3005	Second byte of Qcounter1
write32 0x7828 0xB008	First byte of Qcounter2 (Note: OR'ed with StrobeBit)
write32 0x782C 0x3009	Second byte of Qcounter2
write32 0x7830 0xB00C	First byte of Qcounter3 (Note: OR'ed with StrobeBit)
write32 0x7834 0x300D	Second byte of Qcounter3
write32 0x7838 0x4002	First byte of PWMGen0 (in MS word)
write32 0x783C 0xC003	Second byte of PWMGen0  (Note: OR'ed with StrobeBit)
write32 0x7838 0x4004	First byte of PWMGen1 (in MS word)
write32 0x783C 0xC005	Second byte of PWMGen1  (Note: OR'ed with StrobeBit)
write32 0x7838 0x4008	First byte of PWMGen2 (in MS word)
write32 0x783C 0xC009	Second byte of PWMGen2  (Note: OR'ed with StrobeBit)
write32 0x7838 0x400C	First byte of PWMGen3 (in MS word)
write32 0x783C 0xC00D	Second byte of PWMGen3  (Note: OR'ed with StrobeBit)

Once these 22 address translation table entries are initialized, 
the following sequence of EPP operations will do all the data transfers:

writeaddr 	0x00
writeaddr 	0xFC	This sets up the 16 bit EPP address as 0xFC00 
			= translation region (0x7C00) with auto-inc (0x8000)

writedata	write port 0 Byte 0
writedata	write port 0 Byte 1
writedata	write port 0 Byte 2
readdata	read Port 1 byte 0	 
readdata	read Port 1 byte 1
readdata	read Port 1 byte 2
readdata	read Qcounter 0 byte 0
readdata	read Qcounter 0 byte 1
readdata	read Qcounter 1 byte 0
readdata	read Qcounter 1 byte 1
readdata	read Qcounter 2 byte 0
readdata	read Qcounter 2 byte 1
readdata	read Qcounter 3 byte 0
readdata	read Qcounter 3 byte 1
writedata	write PWMVal 0 byte 0
writedata	write PWMVal 0 byte 1
writedata	write PWMVal 1 byte 0
writedata	write PWMVal 1 byte 1
writedata	write PWMVal 2 byte 0
writedata	write PWMVal 2 byte 1
writedata	write PWMVal 3 byte 0
writedata	write PWMVal 3 byte 1

Notes: For compatibility reasons, basic register access is still 32 bits 
even with address translation, so a 32 bit write is always done even if 
only a single byte is written. This is usually not important, but does 
have some subtle side effects. For example if a 24 bit wide I/O 
port is defined with 16 input bits and 8 output bits (say to interface 
with a 7I37), the 8 output bits can be updated in a single byte write 
thats part of a sequence in the translation RAM. The side effect of this 
is that the 16 unused output bits that coorespond to the input bits on 
the port _will_ be written with random data.


XfrmrOut: The xfrmrout module is used for isolated outputs
using a transformer/rectifier to drive a MOSFET gate

0x7D00        R/W XfrmrOutData  1 to 31 bits of output data per module (1=on)
Bits 0..30 active high data control 

0x7E00        XfrmrOutRate  drive frequency setting divisor and enable
Bits 0..11    Rate divisor sets frequency out 
              frequency=(ClockLow/(Divisor+2))/2
Bit 12        Enable bit  (high to enable) Should be enabled only after I/O
              is setup


InMux: Input multiplexor/expander: uses external multiplexor chips to 
expand inputs. Debounce filtering is provided with an option of long or
short time on a per input basis. Up to 4 MPG encoder counters are provided

0x8000        Control Register
Bits 0..4     MaxBit R/O last mux address (add 1 for number of bits scanned) 
Bit 5         Global invert R/W (inverts all input bits)
Bits 6..15    Rate_Divisor R/W
Bits 16..21   Short time register R/W (0 to 63 scans)
Bits 22..31   Long time register R/W (0 to 1023 scans)
 
Per channel scan rate is (ClockLow/4)/(Rate_divisor+1)
Total scan rate is per channel scan rate/(MaxBit+1)

0x8100	     Filter Register  RW (width = MaxBit+1)

A 1 bit in the filter register selects the long time input filter for
the corresponding input bit, a 0 bit selects the short time. 

0x8200       Filtered Data R/O filtered demuxed data

0x8300       Raw Data R/O raw demuxed data

0x8400       MPG registers 0..3 all 8 bit counters      
(0=LSByte = ins 0,1) etc
0x8400 write LS bit of each byte is mode bit, 0 = 1X mode 1 = 4X mode

InM: Input conditioning/Debounce filtering is provided with an option of long or
short time on a per input basis. Up to 4 mpg encoder channels are provided
same register map as InMux but doesnt use externel mux

0x8500        Control Register
Bits 0..4     MaxBit R/O last address (add 1 for number of bits scanned) 
Bit 5         Global invert R/W (inverts all input bits)
Bits 6..15    Rate_Divisor R/W
Bits 16..21   Short time register R/W (0 to 63 scans)
Bits 22..31   Long time register R/W (0 to 1023 scans)
 
Per channel scan rate is (ClockLow/4)/(Rate_divisor+1)
Total scan rate is per channel scan rate/(MaxBit+1)

0x8600	     Filter Register  RW (width = MaxBit+1)

A 1 bit in the filter register selects the long time input filter for
the corresponding input bit, a 0 bit selects the short time. 

0x8700       Filtered Data R/O filtered demuxed data

0x8800       Raw Data R/O raw demuxed data

0x8900 read  MPG registers 0..3 all 8 bit counters 
(0=LSByte = ins 0,1) etc
0x8900 write LS bit of each byte is mode bit, 0 = 1X mode 1 = 4X mode


DataPainter: 1 bit or 8 bit PWM output motion synchronized data output for 
laser raster/general surface painting modulation

Patterned after the step generators currently 48 bit accumulator = 16 bits data count, 
32 fractional data/rate. That is a 48 bit accumulator with a 32 bit rate added to accumulator.
Data to be output is pushed on a 32 deep by 32 wide FIFO and shifted out 1 bit at a time
(MSb first) in bit mode. In PWM mode each output FIFO word contains 4 PWM data bytes (MSB first)

0x8A00	      Data rate register (R/W)

0x8B00	      32 bit top of accumulator = 16.16 full.fractional data count : Read/write

0x8C00	      Mode0 register, (RT control)
Bit 0	      ProgramMode, R/W. If set DataGate is controlled by ModeReg0 ProgramGate
Bit 1	      ProgramGate, R/W. Controls DataGate if ProgramMode is set, '1' = on
    	      cleared by FIFO underrun
Bit 2	      OffData, R/W. Set output state when DataGate is off
Bit 3	      Hard Gate PWM, If set, gate off PWM at bit level (set output to OffData state when gated)
              If clear, continue to generate PWM when gated off using OffPWM value in mode1 register        
Bit 4	      EnableStart, R/W. Enables DataGate to be set by StartCompare match
Bit 5	      EnableStop, R/W. Enables DataGate to be cleared by StopCompare match
Bit 6	      ClearFIFO, R/W. Clears data FIFO and bit pointer when set (self clearing) 
Bit 7	      DataGate, R/O. Real time DataGate state
Bits 8..13    R/O, FIFO data count (0 to 32) count of 32 bit data words in FIFO
Bits 16..20   R/O, ShiftCount (0..31 for 1 bit mode 0..3 for 8 bit PWM mode)
Bit 21	      R/O, FIFO underun error bit (FIFO out of data)
Bit 22	      R/O, FIFO overrun error bit (FIFO push when full) 	      
Bits 23..31   9 bits R/W real time PWM_scale. PWM value = FIFO data * PWM_Scale
              (256 = 100%) Numbers beyond 256 will wrap

0x8D00	      Mode1 register (Setup)
Bits 0..11    R/W, Clk pulse width in ClockLow units
Bit 12 	      R/W DPLL timer select bit 0
Bit 13        R/W DPLL timer select bit 1
Bit 14        R/W DPLL timer select bit 2
Bit 15        R/W DPLL timer enable, if set,dpainter count is sampled by DPLL timer, 
    	      if clear, dpainter count is sampled by host read
Bit 16        R/W PWM mode, if set FIFO data word is 4x 8 bit PWM
    	      if clear, FIFO data word is 32 bits of on/off video data.
	      PWM is synchronous with data rate (PWM base frequency is 256 * data rate)	  	   
Bit 17	      FiftyPCClk, R/W. When set, clock output is 50% of data bit time
    	      when clear clock width is set by clock width register in Mode1
Bit 23	      R/W debug loop, if set prevents FIFO pop so repeats shift out of current FIFO output word	      
Bits 24..31   R/W Off PWM value (when gated off)

0x8E00	      StartCompare register
Bits 0..15    R/W, 16 bit count compare register for DataGate Set

0x8F00	      StopCompare register
Bits 0..15    R/W, 16 bit count compare register for DataGate Clear

0x9000	      Data register (W/O) 32 deep 32 wide FIFO for video data
 


XY2Mod: XY2-100 module for Galvanometers

32 bit accumulator = 16 bits galvo data on top bits (31 downto 16)
16 bits fractional accel/velocity. That is a 32 bit accumulator with 
a 32 bit rate value (sign extended) and added to accumulator.
accel values are added to velocity only every 4096 clocks
velocity values are added to position only every 256 clocks

0x9200        X Acceleration register (scaled 1/4096) R/W 32
0x9300        Y Acceleration register (scaled 1/4096) R/W 32
0x9400        X Velocity register (scaled 1/256) R/W 32
0x9500        Y Velocity register (scaled 1/256) R/W 32

Position is 16 bit top of accumulator = 16.16 full.fractional X/Y data 
0x9600        X Position register  R/W 32
0x9700        Y Position register  R/W 32
Both position regsisters are bounded at 32767.X

0x9800        Mode register        R/W 11
Bits 0..2     X control bits
Bits 3..5     Y control bits
Bit  6        X position overflow 1 = overflow, write 1 to clear (0 = no-op)
Bit  7	      Y position overflow 1 = overflow, write 1 to clear (0 = no-op)
Bit  8        X velocity overflow 1 = overflow, write 1 to clear (0 = no-op)
Bit  9        Y velocity overflow 1 = overflow, write 1 to clear (0 = no-op)
Bit  10       R/O status bit
0x9900        Timer select/misc register

4 bit master timer select register for DPLL Galvanometer position register
sampling
Bits 15 down to 12 = Timer select bits 3 down to 0 
Timer bits select timers 0 through 4 ( timer 4 is reference time ) 
Any timer select > 4 disables timer based sampling

accumulator addition rate is (ClockLow/2^32)


RCPWM: PWMGEN optimized for RC Servos, The normal PWMgen has low resolution at 50 Hz
and may be needed for high frequency PWM at the same time as  RC servos. A PWMGen
made specically for RC servo fixes both of these issues. Instead of programming
duty cycle like the normal PWMGen, the RCPWMGen sets the pulse width in absolute 
terms, independent of the operating frequency. 

0x9A00        Pulse Width register 0
0x9A04        Pulse Width register 0
0x9A08        Pulse Width register 0
0x9A0C        Pulse Width register 0
...   
                 
Bits 0..16    Pulse width is  16*(register_value+1)/ClockLow
              any register value with bit 16 set =  0 width 

0x9B00	      RCPWMGen master rate register

Bits 31 downto 0  RCPWM pulse frequency = Clocklow(register_value+2)


---------------------------------------------------------------------------
