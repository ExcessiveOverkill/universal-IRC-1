component plasmac "A plasma cutter controller";

description
"""

A plasma cutting table control component for use with the LinuxCNC V2.8 or later.

.I VERSION:
.br
0.190 - 2020 Dec 13

.I SUMMARY:
.br
Usage of this component is demonstrated in the PlasmaC example configurations included with LinuxCNC.

.I DISCLAIMER:
.br
THE AUTHOR OF THIS SOFTWARE ACCEPTS ABSOLUTELY NO LIABILITY FOR ANY HARM OR LOSS RESULTING FROM ITS USE.

IT IS EXTREMELY UNWISE TO RELY ON SOFTWARE ALONE FOR SAFETY.

Any machinery capable of harming persons must have provisions for completely stopping all motors and moving parts etc. before persons enter any danger area.

All machinery must be designed to comply with local and national safety codes, and the author of this software can not, and does not, take any responsibility for such compliance.
""";

/* INPUT PINS */
pin in  float   arc_fail_delay              "arc start failure timeout (seconds)";
pin in  float   arc_lost_delay              "arc lost delay during a cut (seconds)";
pin in  float   arc_ok_high                 "maximum voltage level for Arc OK signal [mode 0] (volts)";
pin in  bit     arc_ok_in                   "external arc ok input signal [mode 1 & mode 2]";
pin in  float   arc_ok_low                  "minimum voltage level for Arc OK signal [mode 0] (volts)";
pin in  s32     arc_max_starts              "maximum attempts at starting the arc";
pin in  float   arc_voltage_in              "arc voltage input [mode 0 & mode 1] see Notes above";
pin in  float   arc_voltage_offset          "offset to set arc voltage to 0 at 0 volts";
pin in  float   arc_voltage_scale           "scale to convert arc_voltage input to actual volts";
pin in  float   axis_z_min_limit            "axis z minimum limit, connect to ini.z.min-limit";
pin in  float   axis_z_max_limit            "axis z maximum limit, connect to ini.z.max-limit";
pin in  float   axis_z_position             "current z axis position, connect to joint.N.pos-fb";
pin in  float   axis_x_position             "current x axis position, connect to axis.x.pos-cmd";
pin in  float   axis_y_position             "current y axis position, connect to axis.y.pos-cmd";
pin in  bit     breakaway                   "torch breakaway switch (optional, see float_switch)";
pin in  bit     spotting_start              "start a new spot, connect to spindle.2.on";
pin in  float   spotting_threshold          "threshold voltage to start spotting delay";
pin in  float   spotting_time               "torch off delay after spotting threshold reached";
pin in  bit     consumable_change           "change consumables in torch";
pin in  bit     cornerlock_enable           "enable corner lock";
pin in  float   cornerlock_threshold        "corner lock threshold (% of requested feed rate), speeds below this disable THC";
pin in  float   current_velocity            "current machine velocity , connect to motion.current-vel";
pin in  float   cut_feed_rate               "cut feed rate, set to 0 to use feed rate from gcod file (machine units per minute)";
pin in  float   cut_height                  "cut height (machine units)";
pin in  bit     cut_recovery                "recover from cut error";
pin in  float   cut_volts                   "cut voltage (volts)";
pin in  bit     cutting_start               "start a new cut, connect to spindle.0.on";
pin in  bit     external_estop              "external estop input";
pin in  float   feed_reduction              "reduce adaptive feed to this percentage (connect to motion.analog-out-03)";
pin in  float   feed_override               "feed override value from gui (connect to halui.feed-override.value)";
pin in  bit     float_switch                "float switch input (can also act as breakaway if it actuates when torch breaks away)";
pin in  float   float_switch_travel         "float switch travel (machine units)";
pin in  float   height_override             "height override adjustment (volts)";
pin in  float   height_per_volt             "torch height change per volt (machine units)";
pin in  bit     homed                       "machine is homed";
pin in  bit     kerfcross_enable            "enable kerf crossing [mode 0 & mode 1]";
pin in  float   kerfcross_override          "kerf crossing threshold override as a percentage";
pin in  float   lowpass_frequency           "lowpass cutoff frequency for arc voltage output";
pin in  bit     ignore_arc_ok_0             "don't require arc ok for start or cutting";
pin in  bit     ignore_arc_ok_1             "don't require arc ok for start or cutting";
pin in  bit     machine_is_on               "machine is on signal";
pin in  bit     mesh_enable                 "enable mesh cutting mode";
pin in  s32     mode                        "operating mode";
pin in  s32     motion_type                 "motion type, connect to motion.motion-type";
pin in  bit     move_down                   "external thc down switch [mode 2])";
pin in  bit     move_up                     "external thc up switch [mode 2]";
pin in  bit     multi_tool                  "allows the use of multiple tools";
pin in  bit     ohmic_probe_enable          "ohmic probe enable input";
pin in  float   ohmic_probe_offset          "Z axis offset for ohmic probe (machine units)";
pin in  s32     ohmic_max_attempts          "maximum ohmic probe attempts before fallback to float switch";
pin in  bit     ohmic_probe                 "ohmic probe input";
pin in  bit     ohmic_test                  "test for shorted torch";
pin in  float   paused_motion_speed         "multiplier for speed of motion when paused, from -1 to 1";
pin in  float   pause_at_end                "time to pause at end of cut";
pin in  float   pid_d_gain                  "derivative gain input [mode 0 & mode 1]";
pin in  float   pid_i_gain                  "integral gain input [mode 0 & mode 1]";
pin in  float   pid_p_gain                  "proportional gain input [mode 0 & mode 1]";
pin in  float   pierce_delay                "time required to pierce stock (seconds)";
pin in  s32     probe_final_speed = 1       "final probe speed (steps per servo period)";
pin in  float   pierce_height               "pierce height (machine units)";
pin in  float   probe_feed_rate             "probe down velocity (machine units per minute)";
pin in  bit     probe_test                  "probe test only";
pin in  float   probe_start_height          "probe starting height";
pin in  bit     program_is_idle             "program is idle, connect to halui.program.is-idle";
pin in  bit     program_is_paused           "program is paused, connect to halui.program.is-paused";
pin in  bit     program_is_running          "program is running, connect to halui.program.is-running";
pin in  float   puddle_jump_delay           "delay move from pierce height to cut height (seconds), leave disconnected if not required";
pin in  float   puddle_jump_height          "puddle jump height (percentage of pierce height), leave disconnected if not required";
pin in  float   requested_velocity          "requested velocity, set by a known requested velocity or connect to motion.requested-vel";
pin in  s32     resolution = 1              "resolution of the offset counts";
pin in  float   restart_delay               "time from arc failure till next restart attempt";
pin in  float   safe_height                 "requested safe traverse height (machine units)";
pin in  float   scribe_arm_delay            "delay from scribe arm to scribe on";
pin in  float   scribe_on_delay             "delay from scribe on to motion beginning";
pin in  bit     scribe_start                "start a new scribe, connect to spindle.1.on";
pin in  float   setup_feed_rate             "feed rate for moves to pierce and cut heights (machine units per minute)";
pin in  float   skip_ihs_distance           "skip IHS if less than this distance from last cut";
pin in  bit     thc_enable                  "enable/disable thc and set the IHS skip type";
pin in  bit     thc_disable                 "thc disable";
pin in  float   thc_delay                   "delay from start of cut to THC enable (seconds)";
pin in  float   thc_feed_rate               "maximum feed rate for thc (machine units per minute)";
pin in  float   thc_threshold               "thc threshold (volts), changes below this have no effect";
pin in  bit     torch_enable                "enable torch";
pin in  bit     torch_off                   "turn torch off";
pin in  bit     torch_pulse_start           "torch pulse start";
pin in  float   torch_pulse_time            "torch pulse time (seconds)";
pin in  float   units_per_mm                "for scale calcs, connect to halui.machine.units-per-mm";
pin in  bit     use_auto_volts              "use calculated voltage for thc baseline";
pin in  float   xy_feed_rate                "feed-rate for consumable change";
pin in  float   x_offset                    "offest to apply to axis x for consumable change";
pin in  float   x_offset_current            "current x axis offset, connect to axis.x.eoffset";
pin in  float   y_offset                    "offest to apply to axis y for consumable change";
pin in  float   y_offset_current            "current z axis offset, connect to axis.y.eoffset";
pin in  float   z_offset_current            "current z axis offset, connect to axis.z.eoffset";

/* OUTPUT PINS */
pin out float   adaptive_feed               "for reverse-run, connect to motion.adaptive-feed";
pin out bit     arc_ok_out                  "arc ok output";
pin out float   arc_voltage_out             "arc voltage output [mode 0 & mode 1]";
pin out bit     consumable_changing         "consumables are being changed";
pin out bit     cornerlock_is_locked        "corner locked indicator";
pin out float   cut_length                  "length of current cut job";
pin out float   cut_time                    "time of current cut job";
pin out bit     cut_recovering              "recovering from cut error";
pin out bit     cutting_stop                "stop manual cut, connect to halui.spindle.0.stop";
pin out bit     feed_hold                   "feed hold, connect to motion.feed_hold";
pin out bit     kerfcross_is_locked         "kerf crossing locked indicator [mode 0 & mode 1]";
pin out bit     led_down                    "thc move down indicator";
pin out bit     led_up                      "thc move up indicator";
pin out float   offset_scale                "offset scale, connect to axis.<x y z>.eoffset-scale";
pin out bit     ohmic_enable                "on only while probing";
pin out s32     pierce_count                "number of pierce attempts";
pin out bit     probe_test_error            "minimum limit reached while pobe testing";
pin out bit     program_pause               "pause the current program, connect to halui.program.pause";
pin out bit     program_resume              "resume the currently paused program, connect to halui.program.resume";
pin out bit     program_run                 "run the currently loaded program, connect to halui.program.run";
pin out bit     program_stop                "stop current program, connect to halui.program.stop";
pin out bit     safe_height_is_limited      "safe height is limited indicator";
pin out bit     scribe_arm                  "arm the scribe";
pin out bit     scribe_on                   "turn scribe on";
pin out s32     state_out                   "current state";
pin out s32     stop_type_out               "current stop type";
pin out bit     thc_active                  "thc status output";
pin out bit     thc_enabled                 "thc is enabled";
pin out bit     torch_on                    "turn torch on, connect to your torch on input";
pin out s32     x_offset_counts             "x offset for consumable change, connect to axis.x.eoffset-counts";
pin out s32     y_offset_counts             "y offset for consumable change, connect to axis.y.eoffset-counts";
pin out bit     xy_offset_enable            "enable x and y offsets, connect to axis.<x & y>.eoffset-enable";
pin out s32     z_offset_counts             "z offset for height control, connect to axis.z.eoffset-counts";
pin out bit     z_offset_enable             "enable z offsets, connect to axis.z.eoffset-enable";
pin out float   z_relative                  "distance of Z from last probed height";

/* VARIABLES */
variable double angle_x_y;                  /* angle for x/y velocity calcs in radians*/
variable int    arc_starts;                 /* number of attempts to start torch */
variable float  arc_fail_timer;             /* arc failure timer */
variable float  arc_lost_timer;             /* arc lost timer */
variable float  arc_voltage_raw;            /* filtered arc voltage to be scaled */
variable float  arc_valid_timer;            /* timer to wait for valid arc_voltage_in */
variable float  axis_x_finish;              /* axis x position at end of cut */
variable float  axis_x_start;               /* axis x position at start of cut */
variable float  axis_y_finish;              /* axis y position at end of cut */
variable float  axis_y_start;               /* axis y position at start of cut */
variable bool   auto_cut;                   /* auto cut mode is active */
variable float  spotting_timer;             /* spotting timer */
variable bool   spotting;                   /* spotting flag */
variable int    count;                      /* for counting */
variable int    cut_height_first;           /* cut height at start of cut */
variable int    cut_height_last;            /* cut height at end of cut */
variable float  cut_offset;                 /* offset from last cut end to this cut start */
variable bool   cut_started;                /* cut has started */
variable int    cut_target;                 /* cut height target offset */
variable bool   error_message;              /* 1 if error message has been sent */
variable bool   first_cut_finished;         /* first cut is complete */
variable bool   float_detected;             /* float switch detected */
variable int    height_ovr_counts;          /* number of counts to change height via override */
variable float  height_ovr_old;             /* old height override value */
variable bool   initialized;                /* initialization flag */
variable float  kerf_ratio;                 /* kerf crossing height to distance ratio */
variable float  kerf_threshold;             /* kerf crossing threshold voltage */
variable int    kerf_errors;                /* number of times kerfcross threshold exceeded */
variable float  last_arc_voltage;           /* last sensed arc voltage */
variable bool   manual_cut;                 /* manual cut mode is active */
variable int    offset_datum;               /* datum for safe height calcs */
variable int    offset_min;                 /* minimum allowed offset */
variable int    offset_max;                 /* maximum allowed offset */
variable int    ohmic_attempts;             /* current ohmic probe attempts */
variable bool   ohmic_detected;             /* true if ohmic probe detected */
variable int    setup_velocity;             /* velocity for setup moves */
variable float  pause_at_end_timer;         /* pause at end of cut timer */
variable bool   paused_motion;              /* paused motion flag */
variable float  paused_motion_timer;        /* minimum run timer for paused motion */
variable float  pid_error_now;              /* current error for pid calcs */
variable float  pid_error_old;              /* old error for pid calcs */
variable float  pid_output;                 /* calculated pid output value */
variable float  pierce_timer;               /* pierce delay timer */
variable int    pierce_target;              /* pierce height target offset */
variable float  probe_at_bottom;            /* probe is at bottom limit */
variable int    probe_force;                /* extra movement of probe after first contact */
variable int    probe_force_val;            /* distance for probe_force */
variable bool   probe_inhibit;              /* inhibit probing */
variable int    probe_offset;               /* offset for active probe */
variable bool   probe_required = 1;         /* a probe sequence is required */
variable bool   probe_retry;                /* probe will retry after contact befor probe height */
variable int    probe_start_target;         /* probe start height target */
variable bool   probe_testing;              /* probe test active */
variable int    probe_velocity;             /* probe down velocity */
variable int    puddle_jump_percent;        /* puddle jump height as percentage of pierce height */
variable int    puddle_jump_target;         /* puddle jump height target offset */
variable float  puddle_jump_timer;          /* puddle jump delay timer */
variable float  recovery_velocity;          /* cut recovery step velocity */
variable float  requested_feed_rate;        /* requested feed rate */
variable float  restart_timer;              /* time between torch on attempts*/
variable int    safe_min;                   /* minimum safe height allowed */
variable int    safe_preferred;             /* preferred safe height offset */
variable int    safe_target;                /* safe height target offset */
variable bool   scribe_pause;               /* scribe pause flag */
variable float  scribe_arm_timer;           /* scribe timer from arm to on*/
variable float  scribe_on_timer;            /* scribe timer from on to motion*/
variable int    state_old = -1;             /* old state*/
variable bool   target_sensed;              /* sensed top of stock */
variable int    target_samples = 6;         /* number of samples for setting target_volts */
variable float  target_total;               /* total voltage of samples for setting target_volts */
variable float  target_volts;               /* target voltage for thc, set by arc voltage at cut height */
variable float  thc_delay_timer;            /* thc delay timer */
variable int    thc_velocity;               /* velocity for thc moves */
variable float  torch_off_timer;            /* arc off delay timer */
variable float  torch_pulse_timer;          /* torch pulse timer */
variable float  velocity_scale;             /* the velocity multipler */
variable int    x_velocity;                 /* velocity for x motion for consumable change */
variable int    y_velocity;                 /* velocity for y motion for consumable change */
variable int    zero_target;                /* zero height target offset */

/* PARAMETERS */
param rw bit    debug_print = FALSE         "print debug messages";
param rw s32    kerf_errors_max = 2         "allowable kerfcross threshold errors";
param rw bit    mesh_arc_ok = FALSE         "don't require arc ok for mesh mode";

/* temp for testing max overrun*/
param rw s32    max_offset = 5              "maximum height offset";

function _;

author "Phillip A Carter";

license "GPLv2 or greater";

option singleton yes;

;;

#include "rtapi_math.h"

typedef enum{IDLE,
             PROBE_HEIGHT,
             PROBE_DOWN,
             PROBE_UP,
             ZERO_HEIGHT,
             PIERCE_HEIGHT,
             TORCH_ON,
             ARC_OK,
             PIERCE_DELAY,
             PUDDLE_JUMP,
             CUT_HEIGHT,
             CUT,
             PAUSE_AT_END,
             SAFE_HEIGHT,
             MAX_HEIGHT,
             FINISH,
             TORCHPULSE,
             PAUSED_MOTION,
             OHMIC_TEST,
             PROBE_TEST,
             SCRIBING,
             CONSUMABLE_CHANGE_ON,
             CONSUMABLE_CHANGE_OFF,
             CUT_RECOVERY_ON,
             CUT_RECOVERY_OFF,
             DEBUG,
            } state_t;

typedef enum{NONE,
             STOP,
             WAIT,
             PAUSE,
            } stop_type_t;

typedef enum{ZERO,
             UP,
             DOWN,
            } move_direction_t;

typedef enum{FLOAT,
             OHMIC,
            } probe_type_t;

typedef enum{EMPTY,
             CUTTING,
             SCRIBE,
             SPOTTING,
            } tool_t;

state_t state = IDLE;
stop_type_t stop_type = NONE;
move_direction_t move_direction = ZERO;
probe_type_t probe_type = FLOAT;
tool_t tool = EMPTY;

FUNCTION(_) {

    /* do these first run only */
    if(!initialized && units_per_mm){
        offset_scale = units_per_mm * fperiod / resolution;
        velocity_scale = resolution / units_per_mm / 60;
        adaptive_feed = 1;
        initialized = TRUE;
        probe_force_val = 5 * resolution;
        recovery_velocity = 3 * resolution;
    }

    /* wait until arc_voltage_in is valid */
    if(isinf(arc_voltage_in) || isnan(arc_voltage_in)){
        arc_valid_timer += fperiod;
        if(arc_valid_timer > 1){
            rtapi_print_msg(RTAPI_MSG_ERR,"invalid arc-voltage-in\n");
            arc_valid_timer = 0;
        } 
        return;
    }

    /* set the active tool */
    if(cutting_start){ //  this allows M3 for cutting as well as M3 $0
        tool = CUTTING;
    }else if(multi_tool && scribe_start && !cutting_start && !spotting_start){
        tool = SCRIBE;
    }else if(multi_tool && spotting_start && !cutting_start && !scribe_start){
        tool = SPOTTING;
    }else{
        tool = EMPTY;
    }

    /* output the relative Z height */
    if(zero_target){
        z_relative = z_offset_current - zero_target * offset_scale;
    }else{
        z_relative = axis_z_position - axis_z_min_limit;
    }

    /* convert feed rates to velocity */
    setup_velocity = setup_feed_rate * velocity_scale;
    if(probe_feed_rate < setup_feed_rate){
        probe_velocity = probe_feed_rate * velocity_scale;
    }else{
        probe_velocity = setup_velocity;
    }
    if(mode == 2){
        thc_velocity = thc_feed_rate * velocity_scale * pid_p_gain / 100;
    }else{
        thc_velocity = thc_feed_rate * velocity_scale;
    }
    if(thc_velocity < 1){
        thc_velocity = 1;
    }

    /* turn torch off if torch off timer completed */
    if(torch_off_timer > 0){
        torch_off_timer -= fperiod;
        if(torch_off_timer <= 0){
            torch_on = FALSE;
            torch_off_timer = 0;
        }
    }

    /* turn torch off from external input */
    if(torch_off){
        torch_on = FALSE;
    }

    /* set THC state */
    thc_enabled = (thc_enable && !thc_disable && !mesh_enable && !ignore_arc_ok_0 && !ignore_arc_ok_1 ? 1:0);

    /* set THC status */
    thc_active = (state == CUT) && ((mode < 2 && target_volts) || (mode == 2 && arc_ok_out)) && thc_enabled && !cornerlock_is_locked && !kerfcross_is_locked ? 1:0;

    /* set ohmic probe state */
    ohmic_detected = ohmic_probe && ohmic_probe_enable;

    /* set adaptive feed reduction if no paused motion */
    if(state != PAUSED_MOTION){
        if(feed_reduction < 10 && state == CUT){
            adaptive_feed = 1;
        }else if(feed_reduction < 100 && state == CUT){
            adaptive_feed = feed_reduction * 0.01;
        }else{
            adaptive_feed = 1;
        }
    }

    /* check for a manual cut */
    if(tool == CUTTING && !auto_cut){
        manual_cut = TRUE;
    }

    /* check for an abort */
    /* or for a pause or wait while active */
    if(auto_cut){
        if(state == IDLE && breakaway && !program_is_idle){
            torch_on = FALSE;
            program_pause = TRUE;
            if(stop_type != WAIT){
                stop_type = PAUSE;
            }
            probe_required = TRUE;
            rtapi_print_msg(RTAPI_MSG_ERR,"breakaway switch activated\n"
                                          "program is paused.\n");
            probe_inhibit = TRUE;
            state = MAX_HEIGHT;
        }else if(!probe_test && (external_estop || program_is_idle) && cut_started && !program_run){
            if(consumable_changing){
                state = CONSUMABLE_CHANGE_OFF;
            }else{
                auto_cut = FALSE;
                if(!pause_at_end){
                    torch_on = FALSE;
                }
                stop_type = STOP;
                program_stop = TRUE;
                cut_started = FALSE;
                probe_required = TRUE;
                axis_x_finish = 0;
                axis_y_finish = 0;
                if(!external_estop){
                    pause_at_end_timer = pause_at_end;
                    state = PAUSE_AT_END;
                }else{
                    state = MAX_HEIGHT;
                }
            }
        }else if(!probe_test && state > IDLE && state <= CUT && stop_type == NONE && cut_started){
            if(program_is_paused){
                torch_on = FALSE;
                stop_type = PAUSE;
                probe_required = TRUE;
                pause_at_end_timer = pause_at_end;
                state = MAX_HEIGHT;
            }else if(tool == EMPTY){
                if(!pause_at_end){
                    torch_on = FALSE;
                }
                stop_type = WAIT;
                if(thc_enabled && ((!use_auto_volts || (use_auto_volts && target_volts)) || !torch_enable)){
                    axis_x_finish = axis_x_position;
                    axis_y_finish = axis_y_position;
                }else{
                    axis_x_finish = 0;
                    axis_y_finish = 0;
                }
                pause_at_end_timer = pause_at_end;
                state = PAUSE_AT_END;
            }else if(breakaway){
                torch_on = FALSE;
                program_pause = TRUE;
                stop_type = PAUSE;
                probe_required = TRUE;
                rtapi_print_msg(RTAPI_MSG_ERR,"breakaway switch activated\n"
                                              "program is paused.\n");
                probe_inhibit = TRUE;
                state = MAX_HEIGHT;
            }else if(state > ARC_OK && float_switch){
                torch_on = FALSE;
                program_pause = TRUE;
                stop_type = PAUSE;
                probe_required = TRUE;
                rtapi_print_msg(RTAPI_MSG_ERR,"float switch activated\n"
                                              "program is paused.\n");
                probe_inhibit = TRUE;
                state = MAX_HEIGHT;
            }else if(state > ARC_OK && ohmic_detected){
                torch_on = FALSE;
                program_pause = TRUE;
                stop_type = PAUSE;
                probe_required = TRUE;
                rtapi_print_msg(RTAPI_MSG_ERR,"ohmic probe activated\n"
                                              "program is paused.\n");
                probe_inhibit = TRUE;
                state = MAX_HEIGHT;
            }else if(state > ARC_OK && !arc_ok_out && torch_enable && !torch_off && !(mesh_enable || ignore_arc_ok_0 || ignore_arc_ok_1)){ ;
                torch_on = FALSE;
                program_pause = TRUE;
                stop_type = PAUSE;
                probe_required = TRUE;
                rtapi_print_msg(RTAPI_MSG_ERR,"valid arc lost\n"
                                              "program is paused.\n");
                state = MAX_HEIGHT;
            }
        }
    }else if(manual_cut){
        if(tool == EMPTY){
            manual_cut = FALSE;
            torch_on = FALSE;
            stop_type = STOP;
            program_stop = TRUE;
            cut_started = FALSE;
            probe_required = TRUE;
            axis_x_finish = 0;
            axis_y_finish = 0;
            state = MAX_HEIGHT;
        }
    }

    /* calculate arc voltage */
    if(lowpass_frequency){
        arc_voltage_raw += (arc_voltage_in - arc_voltage_raw) * (1 - exp(-(2 * M_PI * fabs(lowpass_frequency)) * fperiod));
    }else{
        arc_voltage_raw = arc_voltage_in;
    }
    arc_voltage_out = round(((fabs(arc_voltage_raw) - arc_voltage_offset) * fabs(arc_voltage_scale)) * 1000) / 1000;
    if(arc_voltage_out < 0 && arc_voltage_out > -0.1){
        arc_voltage_out = 0;
    }

    /* set arc ok from either arc ok input of from actual arc voltage
     * if using arc ok input, set arc_ok_low_in and/or arc_ok_high_in to 0 */
    if(mode > 0){
        if(arc_ok_in){
            arc_ok_out = TRUE;
            arc_lost_timer = arc_lost_delay;
        }else if(arc_lost_timer > 0){
            arc_lost_timer -= fperiod;
        }else{
            arc_ok_out = FALSE;
        }
    }else{
        if(arc_voltage_out >= arc_ok_low && arc_voltage_out <= arc_ok_high){
            arc_ok_out = TRUE;
            arc_lost_timer = arc_lost_delay;
        }else if(arc_lost_timer > 0){
            arc_lost_timer -= fperiod;
        }else{
            arc_ok_out = FALSE;
        }
    }

    /* reset program states */
    if(program_is_idle){
        program_stop = FALSE;
        program_resume = FALSE;
    }else if(program_is_paused){
        program_pause = FALSE;
    }else if(program_is_running){
        program_run = FALSE;
        program_resume = FALSE;
        auto_cut = TRUE;
    }

    /* if puddlejump height is 0 then set it to 100 */
    if(puddle_jump_height == 0){
        puddle_jump_percent = 100;
    }else{
        puddle_jump_percent = puddle_jump_height;
    }

    if(!machine_is_on){
        /* if machine is off */
        x_offset_counts = 0;
        y_offset_counts = 0;
        z_offset_counts = 0;
        stop_type = NONE;
        cut_started = FALSE;
        probe_required = TRUE;
        program_stop = FALSE;
        program_resume = FALSE;
        program_pause = FALSE;
        torch_on = FALSE;
        torch_pulse_timer = 0;
        state = IDLE;
    }else{
        /* if machine is on */
        switch(state){
            case IDLE:
                xy_offset_enable = FALSE;
                if((int)floor(z_offset_current / offset_scale) < 0.0000001 &&
                   (int)floor(z_offset_current / offset_scale) > -0.0000001 &&
                   program_is_idle){
                    z_offset_enable = FALSE;
                }
                if(probe_inhibit && !float_switch && !breakaway && !ohmic_detected){
                    probe_inhibit = FALSE;
                }else if(!probe_inhibit){
                    /* if we get a paused motion request and we are paused */
                    if(paused_motion_speed && (stop_type == PAUSE || stop_type == WAIT)){
                        state = PAUSED_MOTION;
                    /* if we get a consumable change start request and we are paused */
                    }else if(consumable_change && (stop_type == PAUSE || stop_type == WAIT) && !consumable_changing){
                        state = MAX_HEIGHT;
                        /* if we get a consumable change stop request and we are changing consumables */
                    }else if(!consumable_change && (stop_type == PAUSE || stop_type == WAIT) && consumable_changing){
                        state = CONSUMABLE_CHANGE_OFF;
                    /* if we get a cut recovery start request and we are paused */
                    }else if(cut_recovery && stop_type == PAUSE && !cut_recovering){
                        state = CUT_RECOVERY_ON;
                    /* if we get a torch start request and we are stopped or waiting for a restart */
                    }else if((tool == CUTTING || tool == SPOTTING || probe_test) && (stop_type == NONE || stop_type == WAIT) && homed){
                        feed_hold = TRUE;
                        stop_type = NONE;
                        //touchdown = FALSE;
                        if(!probe_test){
                            cut_started = TRUE;
                        }else{
                            probe_testing = TRUE;
                        }
                        if(!thc_enabled && first_cut_finished){
                            cut_offset = sqrt(pow(axis_x_start - axis_x_position, 2) + pow(axis_y_start - axis_y_position, 2));
                        }else if((axis_x_finish || axis_y_finish) && first_cut_finished){
                            cut_offset = sqrt(pow(axis_x_finish - axis_x_position, 2) + pow(axis_y_finish - axis_y_position, 2));
                            axis_x_finish = 0;
                            axis_y_finish = 0;
                        }
                        if(cut_offset && cut_offset < skip_ihs_distance && !probe_required){
                            if(thc_enabled){
                                cut_target = cut_target + cut_height_last - cut_height_first;
                                pierce_target = pierce_target + cut_height_last - cut_height_first;
                                puddle_jump_target = puddle_jump_target + cut_height_last - cut_height_first;
                                cut_height_first = cut_height_last;
                            }
                            cut_offset = 0;
                            state = PIERCE_HEIGHT;
                        }else{
                            ohmic_enable = TRUE;
                            if(ohmic_detected && !probe_inhibit){
                                ohmic_enable = FALSE;
                                probe_inhibit = TRUE;
                                if(probe_testing){
                                    rtapi_print_msg(RTAPI_MSG_ERR,"ohmic probe detected before probing.\n"
                                                                  "probe test aborted.");
                                    state = PROBE_TEST;
                                    probe_test_error = TRUE;
                                }else{
                                    stop_type = PAUSE;
                                    program_pause = TRUE;
                                    rtapi_print_msg(RTAPI_MSG_ERR,"ohmic probe detected before probing.\n"
                                                                  "program is paused.\n");
                                }
                            }else if(float_switch && !probe_inhibit){
                                probe_inhibit = TRUE;
                                if(probe_testing){
                                    rtapi_print_msg(RTAPI_MSG_ERR,"float switch detected before probing.\n"
                                                                  "probe test aborted.");
                                    state = PROBE_TEST;
                                    probe_test_error = TRUE;
                                }else{
                                    stop_type = PAUSE;
                                    program_pause = TRUE;
                                    rtapi_print_msg(RTAPI_MSG_ERR,"float switch detected before probing.\n"
                                                                  "program is paused.\n");
                                }
                            }else if(breakaway && !probe_inhibit){
                                probe_inhibit = TRUE;
                                if(probe_testing){
                                    rtapi_print_msg(RTAPI_MSG_ERR,"breakaway switch detected before probing.\n"
                                                                  "probe test aborted.");
                                    state = PROBE_TEST;
                                    probe_test_error = TRUE;
                                }else{
                                    stop_type = PAUSE;
                                    program_pause = TRUE;
                                    rtapi_print_msg(RTAPI_MSG_ERR,"breakaway switch detected before probing.\n"
                                                                  "program is paused.\n");
                                }
                            }else if (!program_is_paused){
                                if(!first_cut_finished){
                                    if(probe_start_height){
                                        probe_start_target = z_offset_counts - ((axis_z_position - axis_z_min_limit - probe_start_height) / offset_scale);
                                    }else{
                                        probe_start_target = z_offset_counts;
                                    }
                                }
                                cut_offset = 0;
                                state = PROBE_HEIGHT;
                            }
                        }
                    /* if we get a resume request and we are paused */
                    }else if(!program_is_paused && stop_type == PAUSE){
                        if(consumable_changing){
                            state = CONSUMABLE_CHANGE_OFF;
                        }else if(motion_type == 1){
                            feed_hold = FALSE;
                        }else{
                            feed_hold = TRUE;
                        }
                        stop_type = NONE;
                    /* if torch pulse requested */
                  }else if(torch_pulse_start && torch_enable && !breakaway && !float_switch && !ohmic_probe){
                        feed_hold = TRUE;
                        state = TORCHPULSE;
                    /* if ohmic probe shorted test requested */
                    }else if(ohmic_test){
                        feed_hold = TRUE;
                        ohmic_enable = TRUE;
                        state = OHMIC_TEST;
                    /* if we get a air-scribe start request */
                    }else if(tool == SCRIBE && !probe_test && homed){
                        state = SCRIBING;
                        scribe_arm_timer = scribe_arm_delay;
                        scribe_pause = FALSE;
                    }else if(!cut_started){
                        feed_hold = FALSE;
                    }
                }
                break;
            case PROBE_HEIGHT:
                z_offset_enable = TRUE;
                stop_type = NONE;
                /* move to probe height at setup speed */
                if(probe_testing && !probe_test){
                    state = PROBE_TEST;
                    break;
                }
                if((float_switch && !float_detected) || ohmic_detected){
                    probe_retry = TRUE;
                    state = PROBE_UP;
                }else if(z_offset_counts - setup_velocity > probe_start_target){
                    z_offset_counts -= setup_velocity;
                }else if(z_offset_counts + setup_velocity < probe_start_target){
                    z_offset_counts += setup_velocity;
                }else if(z_offset_counts > probe_start_target || z_offset_counts < probe_start_target){
                    z_offset_counts = probe_start_target;
                }else{
                    if(float_detected){
                        if(!float_switch){
                            float_detected = FALSE;
                        }
                    }else{
                        state = PROBE_DOWN;
                    }
                }
                break;
            case PROBE_DOWN:
                z_offset_enable = TRUE;
                stop_type = NONE;
                /* probe down to top of stock at probe speed, then push a little further for good contact */
                feed_hold = TRUE;
                if(probe_testing && !probe_test){
                    state = PROBE_TEST;
                    break;
                }
                if(target_sensed){
                    if(probe_force > 0){
                        probe_force -= 1 * resolution;
                        z_offset_counts -= 1 * resolution;
                    }else{
                        target_sensed = FALSE;
                        if(float_switch || ohmic_detected){
                            state = PROBE_UP;
                        }else{
                            rtapi_print_msg(RTAPI_MSG_ERR,"probe trip error while probing.");
                            state = IDLE;
                        }
                    }
                }else if(float_switch && !float_detected){
                    if(ohmic_attempts >= ohmic_max_attempts || !ohmic_probe_enable){
                        probe_type = FLOAT;
                        target_sensed = TRUE;
                        probe_force = probe_force_val;
                        ohmic_attempts = 0;
                        float_detected = FALSE;
                    }else{
                        state = PROBE_HEIGHT;
                        ohmic_attempts += 1;
                        float_detected = TRUE;
                    }
                }else if(ohmic_detected){
                    probe_type = OHMIC;
                    target_sensed = TRUE;
                    probe_force = probe_force_val;
                    ohmic_attempts = 0;
                }else if(!float_switch && !ohmic_detected){
                    if(axis_z_position - (probe_velocity * offset_scale) <= axis_z_min_limit + (0.25 * units_per_mm )){
                        if(probe_at_bottom - z_offset_current < 0.0001){
                            probe_at_bottom = 0;
                            if(!probe_test){
                                rtapi_print_msg(RTAPI_MSG_ERR,"bottom limit reached while probing down.\n"
                                                              "program is paused.\n");
                                stop_type = PAUSE;
                                program_pause = TRUE;
                                state = MAX_HEIGHT;
                            }else{
                                rtapi_print_msg(RTAPI_MSG_ERR,"bottom limit reached while probe testing.\n");
                                state = PROBE_TEST;
                                probe_test_error = TRUE;
                            }
                        }else{
                            probe_at_bottom = z_offset_current;
                        }
                    }else{
                        z_offset_counts -= probe_velocity;
                    }
                }
                break;
            case PROBE_UP:
                z_offset_enable = TRUE;
                stop_type = NONE;
                /* probe up at minimum speed to find top of stock */
                if(probe_testing && !probe_test){
                    state = PROBE_TEST;
                    break;
                }
                if(float_switch || ohmic_detected){
                    if(probe_retry){
                        z_offset_counts += 10 * resolution;
                    }else{
                        if(probe_final_speed > 10){
                            z_offset_counts += 10 * resolution;
                        }else if(probe_final_speed < 1){
                            z_offset_counts += 1 * resolution;
                        }else{
                            z_offset_counts += probe_final_speed * resolution;
                        }
                    }
                }else{
                    if(probe_retry){
                        probe_retry = FALSE;
                        state = PROBE_DOWN;
                        break;
                    }
                    if(probe_type == OHMIC){
                        probe_offset = ohmic_probe_offset / offset_scale;
                    }else{
                        probe_offset = float_switch_travel / offset_scale;
                    }
                    zero_target = z_offset_counts + probe_offset;
                    cut_target = zero_target + (cut_height / offset_scale);
                    pierce_target = zero_target + (pierce_height / offset_scale);
                    puddle_jump_target = zero_target + ((pierce_height * puddle_jump_percent * 0.01) / offset_scale );
                    safe_min = (pierce_height + (1 * units_per_mm)) / offset_scale;
                    safe_preferred = safe_height / offset_scale;
                    offset_min = z_offset_counts - ((axis_z_position - axis_z_min_limit) / offset_scale);
                    offset_max = z_offset_counts + (axis_z_max_limit - axis_z_position - (max_offset * units_per_mm)) / offset_scale;
                    if(safe_height == 0){
                        safe_target = offset_max;
                        ohmic_enable = FALSE;
                        if(ohmic_probe_offset < 0 && probe_type == OHMIC){
                            state = PIERCE_HEIGHT;
                        }else{
                            state = ZERO_HEIGHT;
                        }
                    }else if(z_offset_counts + safe_min >= offset_max){
                        safe_target = offset_max;
                        rtapi_print_msg(RTAPI_MSG_ERR, "material too high for safe traverse.\n"
                                                       "program is paused.\n");
                        stop_type = PAUSE;
                        program_pause = TRUE;
                        state = MAX_HEIGHT;
                    }else if(z_offset_counts + safe_preferred >= offset_max && !safe_height_is_limited){
                        rtapi_print_msg(RTAPI_MSG_ERR, "safe traverse height has been reduced.\n");
                        safe_target = offset_max;
                        safe_height_is_limited = TRUE;
                        ohmic_enable = FALSE;
                        if(ohmic_probe_offset < 0 && probe_type == OHMIC){
                            state = PIERCE_HEIGHT;
                        }else{
                            state = ZERO_HEIGHT;
                        }
                    }else{
                        safe_target = z_offset_counts + safe_preferred;
                        ohmic_enable = FALSE;
                        if(ohmic_probe_offset < 0 && probe_type == OHMIC){
                            state = PIERCE_HEIGHT;
                        }else{
                            state = ZERO_HEIGHT;
                        }
                    }
                }
                break;
            case ZERO_HEIGHT:
                z_offset_enable = TRUE;
                stop_type = NONE;
                probe_required = FALSE;
                if(probe_testing && !probe_test){
                    state = PROBE_TEST;
                    break;
                }
                if(z_offset_counts - setup_velocity > zero_target){
                    z_offset_counts -= setup_velocity;
                }else if(z_offset_counts + setup_velocity < zero_target){
                    z_offset_counts += setup_velocity;
                }else{
                    z_offset_counts = zero_target;
                    axis_x_start = axis_x_position;
                    axis_y_start = axis_y_position;
                    state = PIERCE_HEIGHT;
                }
                break;
            case PIERCE_HEIGHT:
                z_offset_enable = TRUE;
                stop_type = NONE;
                /* move up to pierce height */
                if(probe_testing && !probe_test){
                    state = PROBE_TEST;
                    break;
                }
                if(pierce_height && cut_height && (use_auto_volts || (!use_auto_volts && cut_volts))){
                    feed_hold = TRUE;
                    if(z_offset_counts == pierce_target){
                        if((int)floor(z_offset_current / offset_scale) <= pierce_target + resolution &&
                           (int)floor(z_offset_current / offset_scale) >= pierce_target - resolution){
                            arc_starts = 0;
                            if(probe_testing){
                                state = PROBE_TEST;
                            }else if(!torch_enable){
                                pierce_timer = pierce_delay;
                                state = PIERCE_DELAY;
                            }else if(tool == CUTTING || tool == SPOTTING){
                                state = TORCH_ON;
                            }
                        }
                    }else if(z_offset_counts - setup_velocity > pierce_target){
                        z_offset_counts -= setup_velocity;
                    }else if(z_offset_counts + setup_velocity < pierce_target){
                        z_offset_counts += setup_velocity;
                    }else{
                        z_offset_counts = pierce_target;
                    }
                }else if(!probe_testing){
                    stop_type = PAUSE;
                    program_pause = TRUE;
                    state = MAX_HEIGHT;
                    rtapi_print_msg(RTAPI_MSG_ERR,"invalid pierce height.\n"
                                                  "or invalid cut height.\n"
                                                  "or invalid cut volts.\n"
                                                  "program is paused.");
                }
                break;
            case TORCH_ON:
                stop_type = NONE;
                /* turn torch on and start arc fail timer
                 * if too many attempts then turn torch off, pause program and return to idle state */
                feed_hold = TRUE;
                if(arc_starts > arc_max_starts - 1){
                    restart_timer = 0;
                    if(program_is_idle){
                        cutting_stop = 1;
                        state = MAX_HEIGHT;
                        if (!error_message){
                            rtapi_print_msg(RTAPI_MSG_ERR,"no arc detected after %d start attempts\nmanual cut is stopped.\n", arc_max_starts);
                            error_message = 1;
                        }
                    }else{
                        program_pause = TRUE;
                        if (!error_message){
                            rtapi_print_msg(RTAPI_MSG_ERR,"no arc detected after %d start attempts\nprogram is paused.\n", arc_max_starts);
                            error_message = 1;
                        }
                    }
                }else{
                    error_message = 0;
                    restart_timer -= fperiod;
                    if(restart_timer <= 0){
                        restart_timer = 0;
                        arc_fail_timer = arc_fail_delay;
                        if(torch_enable){
                            torch_on = TRUE;
                            pierce_count += 1;
                        }
                        spotting = FALSE;
                        state = ARC_OK;
                    }
                }
                break;
            case ARC_OK:
                stop_type = NONE;
                /* wait for arc ok
                 * if timeout occurs turn torch off then return to TORCH_ON for another attempt */
                feed_hold = TRUE;
                if(tool == SPOTTING){
                    if(!spotting){
                        if(arc_voltage_out >= spotting_threshold){
                            spotting = TRUE;
                            spotting_timer = spotting_time * 0.001;
                        }
                    }else{
                        spotting_timer -= fperiod;
                        if(spotting_timer <= 0){
                            spotting = FALSE;
                            spotting_timer = 0;
                            torch_on = FALSE;
                            stop_type = WAIT;
                            state = SAFE_HEIGHT;
                        }
                    }
                }
                arc_fail_timer -= fperiod;
                if(arc_fail_timer <= 0){
                    torch_on = FALSE;
                    restart_timer = restart_delay;
                    arc_starts += 1;
                    state = TORCH_ON;
                }else if((arc_ok_out || ignore_arc_ok_0 || ignore_arc_ok_1) && tool != SPOTTING){
                        pierce_timer = pierce_delay;
                        state = PIERCE_DELAY;
                }
                break;
            case PIERCE_DELAY:
                stop_type = NONE;
                /* wait for arc to pierce stock */
                feed_hold = TRUE;
                if(pierce_timer > 0){
                    pierce_timer -= fperiod;
                }else if(!puddle_jump_delay || !puddle_jump_percent){
                    state = CUT_HEIGHT;
                }else{
                    puddle_jump_timer = puddle_jump_delay;
                    state = PUDDLE_JUMP;
                }
                break;
            case PUDDLE_JUMP:
                z_offset_enable = TRUE;
                feed_hold = FALSE;
                /* move to puddle_jump height */
                if(z_offset_counts == puddle_jump_target){
                    if((int)floor(z_offset_current / offset_scale) <= puddle_jump_target + resolution &&
                       (int)floor(z_offset_current / offset_scale) >= puddle_jump_target - resolution){
                        count = 0;
                        if(puddle_jump_timer > 0){
                            puddle_jump_timer -= fperiod;
                        }else{
                            puddle_jump_timer = 0;
                            state = CUT_HEIGHT;
                        }
                    }
                }else if(z_offset_counts - setup_velocity > puddle_jump_target){
                    z_offset_counts -= setup_velocity;
                }else if(z_offset_counts + setup_velocity < puddle_jump_target){
                    z_offset_counts += setup_velocity;
                }else{
                    z_offset_counts = puddle_jump_target;
                }
                break;
            case CUT_HEIGHT:
                z_offset_enable = TRUE;
                stop_type = NONE;
                if(!cut_recovering){
                    feed_hold = FALSE;
                }
                /* move to cut height */
                if(z_offset_counts == cut_target){
                    if((int)floor(z_offset_current / offset_scale) <= cut_target + resolution &&
                       (int)floor(z_offset_current / offset_scale) >= cut_target - resolution){
                        count = 0;
                        /* set feed rate for this cut */
                        if(cut_feed_rate > 0){
                            requested_feed_rate = cut_feed_rate;
                        }else{
                            requested_feed_rate = requested_velocity * 60;
                        }
                        if(cut_recovering){
                            angle_x_y = atan2(-y_offset_counts, -x_offset_counts);
                            x_velocity = fabs(cut_feed_rate * velocity_scale * cos(angle_x_y));
                            y_velocity = fabs(cut_feed_rate * velocity_scale * sin(angle_x_y));
                            state = CUT_RECOVERY_OFF;
                        }else{
                            feed_hold = FALSE;
                            thc_delay_timer = thc_delay;
                            state = CUT;
                        }
                    }
                }else if(z_offset_counts - setup_velocity > cut_target){
                    z_offset_counts -= setup_velocity;
                }else if(z_offset_counts + setup_velocity < cut_target){
                    z_offset_counts += setup_velocity;
                }else{
                    z_offset_counts = cut_target;
                }
                break;
            case CUT:
                /* if program is idle and spindle.0 is off then we shouldn't be here */
                if(program_is_idle && !cutting_start){
                    state = IDLE;
                }
                z_offset_enable = TRUE;
                /* while cutting and it is not a dry run and mesh mode is not enabled:
                 * if thc is enabled then vary the torch height to keep the arc voltage constant
                 * if corner lock enabled, only allow THC if current velocity is greater than the threshold percentage of requested velocity
                 * if kerf crossing is enabled, only allow THC if the voltage change is less than the threshold voltage (modes 0 & 1 only)
                 * adjust torch height and target voltage to suit if height override requested (modes 0 & 1 only)*/
                if(torch_on && !mesh_enable && !ignore_arc_ok_0 && !ignore_arc_ok_1){
                    /* thc control by arc voltage */
                    if(mode < 2){
                        thc_delay_timer -= fperiod;
                        if(thc_delay_timer <= 0){
                            /* set target voltage */
                            if(target_volts == 0){
                                if(use_auto_volts){
                                    /* wait until velocity is at least 99.9% of requested velocity before sampling arc voltage */
                                    if(current_velocity * 60 > requested_feed_rate * feed_override * 0.999){
                                        count += 1;
                                        target_total += arc_voltage_out;
                                        if(count == target_samples){
                                            target_volts = target_total / target_samples;
                                            last_arc_voltage = target_volts;
                                            count = 0;
                                            target_total = 0;
                                        }
                                    }
                                    if(target_volts == 0){
                                        cornerlock_is_locked = TRUE;
                                    }else{
                                        cornerlock_is_locked = FALSE;
                                    }
                                }else{
                                    target_volts = cut_volts;
                                }
                            /* height override setup*/
                            }else if(fabs(height_override - height_ovr_old) > 0.05){
                                height_ovr_counts -= (height_override - height_ovr_old) / 10 * units_per_mm / offset_scale;
                                height_ovr_old = height_override;
                            /* height override z motion */
                            }else if(height_ovr_counts != 0){
                                if((setup_velocity) < height_ovr_counts){
                                    z_offset_counts -= setup_velocity;
                                    height_ovr_counts -= setup_velocity;
                                }else{
                                    z_offset_counts -= height_ovr_counts;
                                    height_ovr_counts = 0;
                                }
                            /* torch height control */
                            }else if(thc_enabled){
                                /* lock thc if velocity < requested velocity * cornerlock threshold percentage */
                                if(cornerlock_enable){
                                    if(current_velocity * 60 < requested_feed_rate * feed_override * cornerlock_threshold * 0.01){
                                        cornerlock_is_locked = TRUE;
                                    }else if(cornerlock_is_locked && current_velocity * 60 > requested_feed_rate * feed_override * 0.99){
                                        cornerlock_is_locked = FALSE;
                                    }
                                }else{
                                    cornerlock_is_locked = FALSE;
                                }
                                /* unlock kerfcross lock if voltage reduced to safe level  */
                                if(kerfcross_is_locked){
    //                                if(arc_voltage_out < last_arc_voltage + (kerf_threshold * 0.05)){
    //                                if(arc_voltage_out < target_volts + (kerf_threshold * 0.5)){
                                    if(arc_voltage_out <= target_volts + kerf_threshold){
                                        kerfcross_is_locked = FALSE;
                                        kerf_errors = 0;
                                    }
                                    last_arc_voltage = arc_voltage_out;
                                /* set kerfcross lock if voltage change > kerfcross threshold volts */
                                }else if(kerfcross_enable){
                                    if(thc_feed_rate < current_velocity * 60){
                                        kerf_ratio = thc_feed_rate / (current_velocity * 60);
                                    }else{
                                        kerf_ratio = 1; /* 45 degree ramp */
                                    }
                                    kerf_threshold = ((kerf_ratio * current_velocity * fperiod) / height_per_volt) * (kerfcross_override * 0.01);
                                    if(arc_voltage_out > last_arc_voltage + kerf_threshold){
    //                                if(arc_voltage_out > target_volts + kerf_threshold){
                                        if(kerf_errors < kerf_errors_max){
                                            kerf_errors += 1;
                                        }
                                        if(kerf_errors == kerf_errors_max){
                                            kerfcross_is_locked = TRUE;
                                        }
                                    }else{
                                        kerf_errors = 0;
                                    }
                                    last_arc_voltage = arc_voltage_out;
                                }
                                /* do thc if ok to go */
                                if(!cornerlock_is_locked && !kerfcross_is_locked){
                                    pid_error_now = (target_volts + height_override - arc_voltage_out) * 0.1;
                                    if(fabs(pid_error_now) < fabs(thc_threshold * 0.1)){
                                        pid_error_now = 0;
                                    }
                                    pid_output = pid_error_now * pid_p_gain;
                                    pid_output += pid_error_now * pid_i_gain * fperiod;
                                    pid_output += (pid_error_now - pid_error_old) * pid_d_gain / fperiod;
                                    pid_error_old = pid_error_now;
                                    if(pid_output > thc_velocity){
                                        pid_output = thc_velocity;
                                    }else if(pid_output < -thc_velocity){
                                        pid_output = -thc_velocity;
                                    }
                                    /* if we hit a soft limit during thc*/
                                    if(z_offset_counts + pid_output <= offset_min || z_offset_counts + pid_output >= offset_max){
                                        torch_on = FALSE;
                                        stop_type = PAUSE;
                                        program_pause = TRUE;
                                        if(z_offset_counts + pid_output <= offset_min){
                                            rtapi_print_msg(RTAPI_MSG_ERR,"bottom limit reached while THC moving down.\n"
                                                                          "program is paused.\n");
                                        }else{
                                            rtapi_print_msg(RTAPI_MSG_ERR,"top limit reached while THC moving up.\n"
                                                                          "program is paused.\n");
                                        }
                                        pid_output = 0;
                                        state = MAX_HEIGHT;

                                    }
                                    z_offset_counts += pid_output;
                                }
                            }
                            if(pid_output > 0){
                                led_up = TRUE;
                            }else if((pid_output) < 0){
                                led_down = TRUE;
                            }else{
                                led_down = FALSE;
                                led_up = FALSE;
                            }
                            pid_output = 0;
                        }
                    }else{ /* thc control by move-up and move-down inputs (no kerf crossing in this mode) */
                        if(thc_enabled){
                            /* lock thc if velocity < requested velocity * cornerlock threshold percentage */
                            if(cornerlock_enable){
                                if(current_velocity * 60 < requested_feed_rate * feed_override * cornerlock_threshold * 0.01){
                                    cornerlock_is_locked = TRUE;
                                }else if(cornerlock_is_locked && current_velocity * 60 > requested_feed_rate * feed_override * 0.99){
                                    cornerlock_is_locked = FALSE;
                                }
                            }else{
                                cornerlock_is_locked = FALSE;
                            }
                            if(move_down && !cornerlock_is_locked){
                                if(z_offset_counts - thc_velocity <= offset_min){
                                    torch_on = FALSE;
                                    stop_type = PAUSE;
                                    program_pause = TRUE;
                                    rtapi_print_msg(RTAPI_MSG_ERR,"bottom limit reached while THC moving down.\n"
                                                                  "program is paused.\n");
                                    state = MAX_HEIGHT;
                                }else{ /* move down at requested velocity */
                                    z_offset_counts -= thc_velocity;
                                    led_down = TRUE;
                                }
                            }else if(move_up && !cornerlock_is_locked){
                                if(z_offset_counts + thc_velocity + safe_min >= offset_max){
                                    torch_on = FALSE;
                                    stop_type = PAUSE;
                                    program_pause = TRUE;
                                    rtapi_print_msg(RTAPI_MSG_ERR,"top limit reached while THC moving up.\n"
                                                                  "program is paused.\n");
                                    state = MAX_HEIGHT;
                                }else{ /* move up at requested velocity */
                                    z_offset_counts += thc_velocity;
                                    led_up = TRUE;
                                }
                            }else{
                                led_down = FALSE;
                                led_up = FALSE;
                            }
                        }
                    }
                    /* check if safe height is below maximium offset */
                    if(z_offset_counts > offset_datum){
                        safe_target += z_offset_counts - offset_datum;
                        offset_datum = z_offset_counts;
                        if(safe_target > offset_max){
                            safe_target = offset_max;
                            if(!safe_height_is_limited){
                                safe_height_is_limited = TRUE;
                                rtapi_print_msg(RTAPI_MSG_ERR, "safe traverse height has been reduced.");
                            }
                        }
                    }
                }
                cut_height_last = z_offset_counts;
                cut_length = cut_length + current_velocity * fperiod;
                cut_time = cut_time + fperiod;
                break;
            case PAUSE_AT_END:
                feed_hold = TRUE;
                pause_at_end_timer -= fperiod;
                if(pause_at_end_timer <= 0){
                    pause_at_end_timer = 0;
                    torch_on = FALSE;
                    if(program_is_idle){
                        state = MAX_HEIGHT;
                    }else{
                        state = SAFE_HEIGHT;
                    }
                }
                break;
            case SAFE_HEIGHT:
                z_offset_enable = TRUE;
                /* move to safe height */
                feed_hold = TRUE;
                if(!torch_off_timer || !torch_on){
                    cornerlock_is_locked = FALSE;
                    if(!probe_test || probe_test_error){
                        if(z_offset_counts == safe_target){
                            if((int)floor(z_offset_current / offset_scale) <= safe_target + resolution &&
                               (int)floor(z_offset_current / offset_scale) >= safe_target - resolution){
                                if(stop_type == WAIT){
                                    feed_hold = FALSE;
                                }
                                first_cut_finished = TRUE;
                                /* do height override here for for remainder of job */
                                height_ovr_old = 0;
                                state = FINISH;
                            }
                        }else if(z_offset_counts - setup_velocity > safe_target){
                            z_offset_counts -= setup_velocity;
                        }else if(z_offset_counts + setup_velocity < safe_target){
                            z_offset_counts += setup_velocity;
                        }else{
                            z_offset_counts = safe_target;
                        }
                    }
                }
                break;
            case MAX_HEIGHT:
                z_offset_enable = TRUE;
                /* move to maximum height */
                feed_hold = TRUE;
                cornerlock_is_locked = FALSE;
                if(!probe_test || probe_test_error){
                    if(z_offset_counts == offset_max){
                        if((int)floor(z_offset_current / offset_scale) <= offset_max + resolution &&
                           (int)floor(z_offset_current / offset_scale) >= offset_max - resolution){
                            if(stop_type == WAIT){
                                feed_hold = FALSE;
                            }
                            /* do height override here for remainder of job */
                            height_ovr_old = 0;
                            if(consumable_change){
                                state = CONSUMABLE_CHANGE_ON;
                            }else if(cut_recovery && stop_type != STOP){
                                state = CUT_RECOVERY_ON;
                            }else{
                                state = FINISH;
                            }
                        }
                    }else if(z_offset_counts - setup_velocity > offset_max){
                        z_offset_counts -= setup_velocity;
                    }else if(z_offset_counts + setup_velocity < offset_max){
                        z_offset_counts += setup_velocity;
                    }else{
                        z_offset_counts = offset_max;
                    }
                }
                break;
            case FINISH:
                /* clean up and return to idle state */
                target_volts = 0;
                cornerlock_is_locked = FALSE;
                kerfcross_is_locked = FALSE;
                led_down = FALSE;
                led_up = FALSE;
                ohmic_enable = FALSE;
                cut_length = 0;
                cut_time = 0;
                probe_test_error = FALSE;
                cutting_stop = 0;
                if(stop_type == STOP){
                    auto_cut = FALSE;
                    manual_cut = FALSE;
                    program_run = FALSE;
                    paused_motion = FALSE;
                    adaptive_feed = 1;
                    if(program_is_idle){
                        z_offset_enable = TRUE;
                        first_cut_finished = FALSE;
                        if(z_offset_counts - setup_velocity > 0){
                            z_offset_counts -= setup_velocity;
                        }else if(z_offset_counts + setup_velocity < 0){
                            z_offset_counts += setup_velocity;
                        }else{
                            z_offset_counts = 0;
                            stop_type = NONE;
                            safe_height_is_limited = FALSE;
                            cut_started = FALSE;
                            /* do height override here for one cut only */
                            /* height_ovr_old = 0; */
                            if(consumable_changing){
                                state = CONSUMABLE_CHANGE_OFF;
                            }
                            if(cut_recovering){
                                angle_x_y = atan2(-y_offset_counts, -x_offset_counts);
                                x_velocity = fabs(cut_feed_rate * velocity_scale * cos(angle_x_y));
                                y_velocity = fabs(cut_feed_rate * velocity_scale * sin(angle_x_y));
                                state = CUT_RECOVERY_OFF;
                                cut_recovering = FALSE;
                            }
                        }
                    }
                }else{
                    if(breakaway){
                        if(!program_is_paused){
                            program_pause = TRUE;
                        }
                    }else{
                        state = IDLE;
                    }
                }
                break;
            case TORCHPULSE:
                /* single pulse the torch on and off */
                if(!torch_on){
                    torch_pulse_timer = torch_pulse_time;
                    if(torch_enable){
                        torch_on = TRUE;
                    }
                }else{
                    if(torch_pulse_timer > 0){
                        torch_pulse_timer -= fperiod;
                    }else{
                        torch_on = FALSE;
                        if(!torch_pulse_start){
                            state = IDLE;
                        }
                    }
                }
                break;
            case PAUSED_MOTION:
                /* a bit kludgy but we need a timer here for a minimum run
                 * time to give the GUI time to poll the status channel */
                if(paused_motion_speed){
                    if(!paused_motion){
                        paused_motion_timer = 0.2; /* 0.2 seconds */
                        paused_motion = TRUE;
                        adaptive_feed = paused_motion_speed;
                        feed_hold = FALSE;
                        program_resume = TRUE;
                    }else{
                        paused_motion_timer -= fperiod;
                    }
                }else{
                    paused_motion_timer -= fperiod;
                    feed_hold = TRUE;
                    program_pause = TRUE;
                    if(program_is_paused && paused_motion_timer <= 0){
                        paused_motion = FALSE;
                        adaptive_feed = 1;
                        if(cut_recovery){
                            state = CUT_RECOVERY_ON;
                        }else{
                            state = IDLE;
                        }
                    }
                }
                break;
            case OHMIC_TEST:
                /* wait here until ohmic_test input released */
                if (!ohmic_test){
                    ohmic_enable = FALSE;
                    state = IDLE;
                }
                break;
            case PROBE_TEST:
                z_offset_enable = TRUE;
                /* wait here until probe_test input released */
                if(!probe_test){
                    probe_testing = FALSE;
                    if(z_offset_counts - setup_velocity > 0){
                        z_offset_counts -= setup_velocity;
                    }else if(z_offset_counts + setup_velocity < 0){
                        z_offset_counts += setup_velocity;
                    }else{
                        z_offset_counts = 0;
                        probe_inhibit = FALSE;
                        state = FINISH;
                    }
                }
                break;
            case SCRIBING:
                if(tool == SCRIBE){
                    if(!program_is_paused){
                        scribe_arm = TRUE;

                        if(scribe_arm_timer){
                            feed_hold = TRUE;
                            scribe_arm_timer -= fperiod;
                            if(scribe_arm_timer < 0){
                                scribe_arm_timer = 0;
                            }
                        }else if(scribe_on_timer){
                            feed_hold = TRUE;
                            scribe_on_timer -= fperiod;
                            if(scribe_on_timer < 0){
                                scribe_on_timer = 0;
                            }
                        }else if(scribe_arm && !scribe_arm_timer && !scribe_on){
                            feed_hold = TRUE;
                            scribe_on_timer = scribe_on_delay;
                            scribe_on = TRUE;
                        }else if(scribe_on && !scribe_on_timer){
                            feed_hold = FALSE;
                        }
                    }else{
                        scribe_arm = FALSE;
                        scribe_on = FALSE;
                        scribe_arm_timer = scribe_arm_delay;
                        scribe_on_timer = 0;
                    }
                }else{
                    scribe_arm = FALSE;
                    scribe_on = FALSE;
                    scribe_arm_timer = 0;
                    scribe_on_timer = 0;
                    state = IDLE;
                }
                break;
            case CONSUMABLE_CHANGE_ON:
                xy_offset_enable = TRUE;
                feed_hold = TRUE;
                if(!consumable_changing){
                    if(x_offset == 0 && y_offset == 0){
                        x_velocity = 0;
                        y_velocity = 0;
                    }else if(x_offset == 0){
                        x_velocity = 0;
                        y_velocity = xy_feed_rate * velocity_scale;
                    }else if(y_offset == 0){
                        x_velocity = xy_feed_rate * velocity_scale;
                    }else{
                        angle_x_y = atan2(y_offset, x_offset);
                        x_velocity = fabs(xy_feed_rate * velocity_scale * cos(angle_x_y));
                        y_velocity = fabs(xy_feed_rate * velocity_scale * sin(angle_x_y));
                    }
                    consumable_changing = TRUE;
                }else{
                    if(consumable_change){
                        if(x_velocity && x_offset_counts != x_offset){
                            if(x_offset > 0){
                                if(x_offset_counts + x_velocity < x_offset){
                                    x_offset_counts += x_velocity;
                                }else{
                                    x_offset_counts = x_offset;
                                }
                            }else{
                                if(x_offset_counts - x_velocity > x_offset){
                                    x_offset_counts -= x_velocity;
                                }else{
                                    x_offset_counts = x_offset;
                                }
                            }
                        }
                        if(y_velocity && y_offset_counts != y_offset){
                            if(y_offset > 0){
                                if(y_offset_counts + y_velocity < y_offset){
                                    y_offset_counts += y_velocity;
                                }else{
                                    y_offset_counts = y_offset;
                                }
                            }else{
                                if(y_offset_counts - y_velocity > y_offset){
                                    y_offset_counts -= y_velocity;
                                }else{
                                    y_offset_counts = y_offset;
                                }
                            }
                        }
                    }
                }
                if((x_offset_counts == x_offset && y_offset_counts == y_offset) || !consumable_change){
                    state = IDLE;
                }
                break;
            case CONSUMABLE_CHANGE_OFF:
                xy_offset_enable = TRUE;
                if(x_velocity && x_offset_counts != 0){
                    if(x_offset_counts > 0){
                        if(x_offset_counts - x_velocity > 0){
                            x_offset_counts -= x_velocity;
                        }else{
                            x_offset_counts = 0;
                        }
                    }else{
                        if(x_offset_counts + x_velocity < 0){
                            x_offset_counts += x_velocity;
                        }else{
                            x_offset_counts = 0;
                        }
                    }
                }
                if(y_velocity && y_offset_counts != 0){
                    if(y_offset_counts > 0){
                        if(y_offset_counts - y_velocity > 0){
                            y_offset_counts -= y_velocity;
                        }else{
                            y_offset_counts = 0;
                        }
                    }else{
                        if(y_offset_counts + y_velocity < 0){
                            y_offset_counts += y_velocity;
                        }else{
                            y_offset_counts = 0;
                        }
                    }
                }
                if(x_offset_current < 0.05 * units_per_mm &&
                   x_offset_current > -0.05 * units_per_mm &&
                   y_offset_current < 0.05 * units_per_mm &&
                   y_offset_current > -0.05 * units_per_mm){
                    consumable_changing = FALSE;
                    feed_hold = FALSE;
                    state = IDLE;
                }
                break;
            case CUT_RECOVERY_ON:
                xy_offset_enable = TRUE;
                if(program_is_running){
                    state = IDLE;
                }
                if(!cut_recovering){
                    cut_recovering = TRUE;
                }
                if(cut_recovery){
                    if(x_offset_counts != x_offset){
                        if(x_offset_counts + recovery_velocity < x_offset){
                            x_offset_counts += recovery_velocity;
                        }else if(x_offset_counts - recovery_velocity > x_offset){
                            x_offset_counts -= recovery_velocity;
                        }else{
                            x_offset_counts = x_offset;
                        }
                    }
                    if(y_offset_counts != y_offset){
                        if(y_offset_counts + recovery_velocity < y_offset){
                            y_offset_counts += recovery_velocity;
                        }else if(y_offset_counts - recovery_velocity > y_offset){
                            y_offset_counts -= recovery_velocity;
                        }else{
                            y_offset_counts = y_offset;
                        }
                    }
                }else{
                    angle_x_y = atan2(-y_offset_counts, -x_offset_counts);
                    x_velocity = fabs(cut_feed_rate * velocity_scale * cos(angle_x_y));
                    y_velocity = fabs(cut_feed_rate * velocity_scale * sin(angle_x_y));
                    cut_recovering = FALSE;
                    state = CUT_RECOVERY_OFF;
                }
                if(paused_motion_speed){
                    state = PAUSED_MOTION;
                }
                break;
            case CUT_RECOVERY_OFF:
                xy_offset_enable = TRUE;
                if(x_offset_current <= 0.01 * units_per_mm &&
                   x_offset_current >= -0.01 * units_per_mm &&
                   y_offset_current <= 0.01 * units_per_mm &&
                   y_offset_current >= -0.01 * units_per_mm){
                    if(cut_recovery){
                        cut_recovering = FALSE;
                        feed_hold = FALSE;
                        thc_delay_timer = thc_delay;
                        state = CUT;
                    }else{
                        state = IDLE;
                    }
                }else{
                    if(x_offset_counts + x_velocity < 0){
                        x_offset_counts += x_velocity;
                    }else if(x_offset_counts - x_velocity > 0){
                        x_offset_counts -= x_velocity;
                    }else{
                        x_offset_counts = 0;
                    }
                    if(y_offset_counts + y_velocity < 0){
                        y_offset_counts += y_velocity;
                    }else if(y_offset_counts - y_velocity > 0){
                        y_offset_counts -= y_velocity;
                    }else{
                        y_offset_counts = 0;
                    }
                }
                break;
            case DEBUG:
                /* holding state for debugging */
                rtapi_print_msg(RTAPI_MSG_ERR, "We should never end up here...\n");
                break;
        }
    }

    /* set status pins */
    state_out = state;
    stop_type_out = stop_type;

    /* debug print */
    if(debug_print && state_old != state){
        if(rtapi_get_msg_level() != 3){
            rtapi_set_msg_level(3);
        }
        state_old = state;
        switch(state){
            case 0:
                rtapi_print_msg(RTAPI_MSG_INFO, "IDLE\n");
                break;
            case 1:
                rtapi_print_msg(RTAPI_MSG_INFO, "PROBE_HEIGHT\n");
                break;
            case 2:
                rtapi_print_msg(RTAPI_MSG_INFO, "PROBE_DOWN\n");
                break;
            case 3:
                rtapi_print_msg(RTAPI_MSG_INFO, "PROBE_UP\n");
                break;
            case 4:
                rtapi_print_msg(RTAPI_MSG_INFO, "ZERO_HEIGHT\n");
                break;
            case 5:
                rtapi_print_msg(RTAPI_MSG_INFO, "PIERCE_HEIGHT\n");
                break;
            case 6:
                rtapi_print_msg(RTAPI_MSG_INFO, "TORCH_ON\n");
                break;
            case 7:
                rtapi_print_msg(RTAPI_MSG_INFO, "ARC_OK\n");
                break;
            case 8:
                rtapi_print_msg(RTAPI_MSG_INFO, "PIERCE_DELAY\n");
                break;
            case 9:
                rtapi_print_msg(RTAPI_MSG_INFO, "PUDDLE_JUMP\n");
                break;
            case 10:
                rtapi_print_msg(RTAPI_MSG_INFO, "CUT_HEIGHT\n");
                break;
            case 11:
                rtapi_print_msg(RTAPI_MSG_INFO, "CUT\n");
                break;
            case 12:
                rtapi_print_msg(RTAPI_MSG_INFO, "PAUSE_AT_END\n");
                break;
            case 13:
                rtapi_print_msg(RTAPI_MSG_INFO, "SAFE_HEIGHT\n");
                break;
            case 14:
                rtapi_print_msg(RTAPI_MSG_INFO, "MAX_HEIGHT\n");
                break;
            case 15:
                rtapi_print_msg(RTAPI_MSG_INFO, "FINISH\n");
                break;
            case 16:
                rtapi_print_msg(RTAPI_MSG_INFO, "TORCHPULSE\n");
                break;
            case 17:
                rtapi_print_msg(RTAPI_MSG_INFO, "PAUSED_MOTION\n");
                break;
            case 18:
                rtapi_print_msg(RTAPI_MSG_INFO, "OHMIC_TEST\n");
                break;
            case 19:
                rtapi_print_msg(RTAPI_MSG_INFO, "PROBE_TEST\n");
                break;
            case 20:
                rtapi_print_msg(RTAPI_MSG_INFO, "SCRIBING\n");
                break;
            case 21:
                rtapi_print_msg(RTAPI_MSG_INFO, "CONSUMABLE_CHANGE_ON\n");
                break;
            case 22:
                rtapi_print_msg(RTAPI_MSG_INFO, "CONSUMABLE_CHANGE_OFF\n");
                break;
            case 23:
                rtapi_print_msg(RTAPI_MSG_INFO, "CUT_RECOVERY_ON\n");
                break;
            case 24:
                rtapi_print_msg(RTAPI_MSG_INFO, "CUT_RECOVERY_OFF\n");
                break;
            case 25:
                rtapi_print_msg(RTAPI_MSG_INFO, "DEBUG\n");
                break;
        }
    }

}
