/*[# This is the original template, thus the warning below does not apply to this file #]
 * ============================ WARNING ============================
 * ==== This is an autogenerated file.                          ====
 * ==== Any changes to this file will be lost when recompiling. ====
 * =================================================================
 *
 * This file contains support functions for the ODrive ASCII protocol.
 *
 * TODO: might generalize this as an approach to runtime introspection.
 */

#include <fibre/introspection.hpp>

#pragma GCC push_options
#pragma GCC optimize ("s")

[% for intf in interfaces.values() %][% if not intf.builtin %]
template<typename T>
struct [[intf.fullname | to_pascal_case]]TypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const [[intf.fullname | to_pascal_case]]TypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
[%- for property in intf.get_all_attributes().values() %]
            case [[loop.index0]]: *(decltype([[intf.c_name]]::get_[[property.name]](std::declval<T*>()))*)(&res) = [[intf.c_name]]::get_[[property.name]](ptr); break;
[%- endfor %]
        }
        return res;
    }
};
[% endif %][% endfor %]

[% for intf in interfaces.values() %][% if not intf.builtin %]
template<typename T>
const PropertyInfo [[intf.fullname | to_pascal_case]]TypeInfo<T>::property_table[] = {
[%- for property in intf.get_all_attributes().values() %]
    {"[[property.name]]", &[[(property.type.purename or property.type.fullname) | to_pascal_case]]TypeInfo<std::remove_reference_t<decltype(*[[intf.c_name]]::get_[[property.name]](std::declval<T*>()))>>::singleton},
[%- endfor %]
};
template<typename T>
const [[intf.fullname | to_pascal_case]]TypeInfo<T> [[intf.fullname | to_pascal_case]]TypeInfo<T>::singleton{[[intf.fullname | to_pascal_case]]TypeInfo<T>::property_table, sizeof([[intf.fullname | to_pascal_case]]TypeInfo<T>::property_table) / sizeof([[intf.fullname | to_pascal_case]]TypeInfo<T>::property_table[0])};

[% endif %][% endfor %]

#pragma GCC pop_options
