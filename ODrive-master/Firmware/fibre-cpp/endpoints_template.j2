/*[# This is the original template, thus the warning below does not apply to this file #]
 * ============================ WARNING ============================
 * ==== This is an autogenerated file.                          ====
 * ==== Any changes to this file will be lost when recompiling. ====
 * =================================================================
 *
 * This file contains the toplevel handler for Fibre v0.1 endpoint operations.
 *
 * This endpoint-oriented approach will be deprecated in Fibre v0.2 in favor of
 * a function-oriented approach and a more powerful object model.
 *
 */
#ifndef __FIBRE_ENDPOINTS_HPP
#define __FIBRE_ENDPOINTS_HPP

#include <fibre/introspection.hpp>
#include <fibre/../../legacy_protocol.hpp>
#include <fibre/../../crc.hpp>

// Note: with -Og the functions with large switch statements reserves a huge amount
// of stack space because they reserves separate space for the stack frame of each
// of the inlined functions.
// The minimum known set of flags to prevent this is `-O1 -fipa-sra`.
// `-O2`, `-O3` and `-Os` are supersets of this.

#pragma GCC push_options
#pragma GCC optimize ("s")

namespace fibre {

const unsigned char embedded_json[] = [[embedded_endpoint_definitions | to_c_string]];
const size_t embedded_json_length = sizeof(embedded_json) - 1;
const uint16_t json_crc_ = calc_crc16<CANONICAL_CRC16_POLYNOMIAL>(PROTOCOL_VERSION, embedded_json, embedded_json_length);
const uint32_t json_version_id_ = (json_crc_ << 16) | calc_crc16<CANONICAL_CRC16_POLYNOMIAL>(json_crc_, embedded_json, embedded_json_length);

static void get_property(Introspectable& result, size_t idx) {
    switch (idx) {
[%- for endpoint in endpoints %]
[%- if endpoint.function.name == 'exchange' and endpoint.in_bindings | list == ['obj'] %]
        case [[endpoint.id]]: { [[(endpoint.in_bindings['obj'] + '$') | replace(')$', ', &result.storage_)')]]; result.type_info_ = &FibrePropertyTypeInfo<[[endpoint.function.in['obj'].type.c_name]]>::singleton; } break;
[%- endif %]
[%- endfor %]
        default: break;
    }
}


bool endpoint_handler(int idx, cbufptr_t* input_buffer, bufptr_t* output_buffer) {
    //Introspectable property = get_property(idx);
    //if property.is_valid()

    switch (idx) {
[%- for endpoint in endpoints %]
[%- if (endpoint.function.name == 'exchange' or endpoint.function.name == 'read') and endpoint.in_bindings | list == ['obj'] %]
        case [[endpoint.id]]: { return [[endpoint.function.fullname | to_snake_case]]([% for k, arg in endpoint.function.in.items() %][% if k in endpoint.in_bindings %]static_cast<[[arg.type.c_name]]>([[endpoint.in_bindings[k]]])[% else %]std::nullopt[% endif %], [% endfor %][% for k, arg in endpoint.function.out.items() %][% if k in endpoint.out_bindings %]static_cast<[[arg.type.c_name]]*>([[endpoint.out_bindings[k]]])[% else %]nullptr[% endif %], [% endfor %]input_buffer, output_buffer); } break;
[%- else %]
        case [[endpoint.id]]: { return [[endpoint.function.fullname | to_snake_case]]([% for k, arg in endpoint.function.in.items() %][% if k in endpoint.in_bindings %]static_cast<[[arg.type.c_name]]>([[endpoint.in_bindings[k]]])[% else %]std::nullopt[% endif %], [% endfor %][% for k, arg in endpoint.function.out.items() %][% if k in endpoint.out_bindings %]static_cast<[[arg.type.c_name]]*>([[endpoint.out_bindings[k]]])[% else %]nullptr[% endif %], [% endfor %]input_buffer, output_buffer); } break;
[%- endif %]
[%- endfor %]
        default: return false;
    }
}

bool is_endpoint_ref_valid(endpoint_ref_t endpoint_ref) {
    if (endpoint_ref.json_crc != json_crc_) {
        return false;
    }

    switch (endpoint_ref.endpoint_id) {
[%- for endpoint in endpoints %]
        case [[endpoint.id]]: return true;
[%- endfor %]
        default: return false;
    }
}

bool set_endpoint_from_float(endpoint_ref_t endpoint_ref, float value) {
    if (endpoint_ref.json_crc != json_crc_) {
        return false;
    }

    Introspectable property{};
    get_property(property, endpoint_ref.endpoint_id);
    const FloatSettableTypeInfo* type_info = dynamic_cast<const FloatSettableTypeInfo*>(property.get_type_info());
    return type_info && type_info->set_float(property, value);
}

}

#pragma GCC pop_options

#endif // __FIBRE_ENDPOINTS_HPP