/*
* This file was autogenerated using the "odrivetool generate-code" feature.
*
* The file matches a specific firmware version. If you add/remove/rename any
* properties exposed by the ODrive, this file needs to be regenerated, otherwise
* the ODrive will ignore all commands.
*/

#ifndef __ODRIVE_ENDPOINTS_HPP
#define __ODRIVE_ENDPOINTS_HPP


namespace odrive {
    
static constexpr const uint16_t json_crc = 0xbe97;

static constexpr const uint16_t per_axis_offset = 101;

enum { 
    VBUS_VOLTAGE = 1,
    SERIAL_NUMBER = 2,
    HW_VERSION_MAJOR = 3,
    HW_VERSION_MINOR = 4,
    HW_VERSION_VARIANT = 5,
    FW_VERSION_MAJOR = 6,
    FW_VERSION_MINOR = 7,
    FW_VERSION_REVISION = 8,
    FW_VERSION_UNRELEASED = 9,
    USER_CONFIG_LOADED = 10,
    BRAKE_RESISTOR_ARMED = 11,
    SYSTEM_STATS__UPTIME = 12,
    SYSTEM_STATS__MIN_HEAP_SPACE = 13,
    SYSTEM_STATS__MIN_STACK_SPACE_AXIS0 = 14,
    SYSTEM_STATS__MIN_STACK_SPACE_AXIS1 = 15,
    SYSTEM_STATS__MIN_STACK_SPACE_COMMS = 16,
    SYSTEM_STATS__MIN_STACK_SPACE_USB = 17,
    SYSTEM_STATS__MIN_STACK_SPACE_UART = 18,
    SYSTEM_STATS__MIN_STACK_SPACE_USB_IRQ = 19,
    SYSTEM_STATS__MIN_STACK_SPACE_STARTUP = 20,
    SYSTEM_STATS__USB__RX_CNT = 21,
    SYSTEM_STATS__USB__TX_CNT = 22,
    SYSTEM_STATS__USB__TX_OVERRUN_CNT = 23,
    SYSTEM_STATS__I2C__ADDR = 24,
    SYSTEM_STATS__I2C__ADDR_MATCH_CNT = 25,
    SYSTEM_STATS__I2C__RX_CNT = 26,
    SYSTEM_STATS__I2C__ERROR_CNT = 27,
    CONFIG__BRAKE_RESISTANCE = 28,
    CONFIG__ENABLE_UART = 29,
    CONFIG__ENABLE_I2C_INSTEAD_OF_CAN = 30,
    CONFIG__DC_BUS_UNDERVOLTAGE_TRIP_LEVEL = 31,
    CONFIG__DC_BUS_OVERVOLTAGE_TRIP_LEVEL = 32,
    TEST_PROPERTY = 235,
    ADC_GPIO1 = 242,
    ADC_GPIO2 = 243,
    SAVE_CONFIGURATION = 244,
    ERASE_CONFIGURATION = 245,
    REBOOT = 246,
    ENTER_DFU_MODE = 247,

    // Per-Axis endpoints (to be used with read_axis_property and write_axis_property)
    AXIS__ERROR = 33,
    AXIS__ENABLE_STEP_DIR = 34,
    AXIS__CURRENT_STATE = 35,
    AXIS__REQUESTED_STATE = 36,
    AXIS__LOOP_COUNTER = 37,
    AXIS__CONFIG__STARTUP_MOTOR_CALIBRATION = 38,
    AXIS__CONFIG__STARTUP_ENCODER_INDEX_SEARCH = 39,
    AXIS__CONFIG__STARTUP_ENCODER_OFFSET_CALIBRATION = 40,
    AXIS__CONFIG__STARTUP_CLOSED_LOOP_CONTROL = 41,
    AXIS__CONFIG__STARTUP_SENSORLESS_CONTROL = 42,
    AXIS__CONFIG__ENABLE_STEP_DIR = 43,
    AXIS__CONFIG__COUNTS_PER_STEP = 44,
    AXIS__CONFIG__RAMP_UP_TIME = 45,
    AXIS__CONFIG__RAMP_UP_DISTANCE = 46,
    AXIS__CONFIG__SPIN_UP_CURRENT = 47,
    AXIS__CONFIG__SPIN_UP_ACCELERATION = 48,
    AXIS__CONFIG__SPIN_UP_TARGET_VEL = 49,
    AXIS__MOTOR__ERROR = 50,
    AXIS__MOTOR__ARMED_STATE = 51,
    AXIS__MOTOR__IS_CALIBRATED = 52,
    AXIS__MOTOR__CURRENT_MEAS_PHB = 53,
    AXIS__MOTOR__CURRENT_MEAS_PHC = 54,
    AXIS__MOTOR__DC_CALIB_PHB = 55,
    AXIS__MOTOR__DC_CALIB_PHC = 56,
    AXIS__MOTOR__PHASE_CURRENT_REV_GAIN = 57,
    AXIS__MOTOR__CURRENT_CONTROL__P_GAIN = 58,
    AXIS__MOTOR__CURRENT_CONTROL__I_GAIN = 59,
    AXIS__MOTOR__CURRENT_CONTROL__V_CURRENT_CONTROL_INTEGRAL_D = 60,
    AXIS__MOTOR__CURRENT_CONTROL__V_CURRENT_CONTROL_INTEGRAL_Q = 61,
    AXIS__MOTOR__CURRENT_CONTROL__IBUS = 62,
    AXIS__MOTOR__CURRENT_CONTROL__FINAL_V_ALPHA = 63,
    AXIS__MOTOR__CURRENT_CONTROL__FINAL_V_BETA = 64,
    AXIS__MOTOR__CURRENT_CONTROL__IQ_SETPOINT = 65,
    AXIS__MOTOR__CURRENT_CONTROL__IQ_MEASURED = 66,
    AXIS__MOTOR__CURRENT_CONTROL__MAX_ALLOWED_CURRENT = 67,
    AXIS__MOTOR__GATE_DRIVER__DRV_FAULT = 68,
    AXIS__MOTOR__TIMING_LOG__TIMING_LOG_GENERAL = 69,
    AXIS__MOTOR__TIMING_LOG__TIMING_LOG_ADC_CB_I = 70,
    AXIS__MOTOR__TIMING_LOG__TIMING_LOG_ADC_CB_DC = 71,
    AXIS__MOTOR__TIMING_LOG__TIMING_LOG_MEAS_R = 72,
    AXIS__MOTOR__TIMING_LOG__TIMING_LOG_MEAS_L = 73,
    AXIS__MOTOR__TIMING_LOG__TIMING_LOG_ENC_CALIB = 74,
    AXIS__MOTOR__TIMING_LOG__TIMING_LOG_IDX_SEARCH = 75,
    AXIS__MOTOR__TIMING_LOG__TIMING_LOG_FOC_VOLTAGE = 76,
    AXIS__MOTOR__TIMING_LOG__TIMING_LOG_FOC_CURRENT = 77,
    AXIS__MOTOR__CONFIG__PRE_CALIBRATED = 78,
    AXIS__MOTOR__CONFIG__POLE_PAIRS = 79,
    AXIS__MOTOR__CONFIG__CALIBRATION_CURRENT = 80,
    AXIS__MOTOR__CONFIG__RESISTANCE_CALIB_MAX_VOLTAGE = 81,
    AXIS__MOTOR__CONFIG__PHASE_INDUCTANCE = 82,
    AXIS__MOTOR__CONFIG__PHASE_RESISTANCE = 83,
    AXIS__MOTOR__CONFIG__DIRECTION = 84,
    AXIS__MOTOR__CONFIG__MOTOR_TYPE = 85,
    AXIS__MOTOR__CONFIG__CURRENT_LIM = 86,
    AXIS__CONTROLLER__POS_SETPOINT = 87,
    AXIS__CONTROLLER__VEL_SETPOINT = 88,
    AXIS__CONTROLLER__VEL_INTEGRATOR_CURRENT = 89,
    AXIS__CONTROLLER__CURRENT_SETPOINT = 90,
    AXIS__CONTROLLER__CONFIG__CONTROL_MODE = 91,
    AXIS__CONTROLLER__CONFIG__POS_GAIN = 92,
    AXIS__CONTROLLER__CONFIG__VEL_GAIN = 93,
    AXIS__CONTROLLER__CONFIG__VEL_INTEGRATOR_GAIN = 94,
    AXIS__CONTROLLER__CONFIG__VEL_LIMIT = 95,
    AXIS__CONTROLLER__START_ANTICOGGING_CALIBRATION = 105,
    AXIS__ENCODER__ERROR = 106,
    AXIS__ENCODER__IS_READY = 107,
    AXIS__ENCODER__INDEX_FOUND = 108,
    AXIS__ENCODER__SHADOW_COUNT = 109,
    AXIS__ENCODER__COUNT_IN_CPR = 110,
    AXIS__ENCODER__OFFSET = 111,
    AXIS__ENCODER__INTERPOLATION = 112,
    AXIS__ENCODER__PHASE = 113,
    AXIS__ENCODER__POS_ESTIMATE = 114,
    AXIS__ENCODER__POS_CPR = 115,
    AXIS__ENCODER__HALL_STATE = 116,
    AXIS__ENCODER__PLL_VEL = 117,
    AXIS__ENCODER__PLL_KP = 118,
    AXIS__ENCODER__PLL_KI = 119,
    AXIS__ENCODER__CONFIG__MODE = 120,
    AXIS__ENCODER__CONFIG__USE_INDEX = 121,
    AXIS__ENCODER__CONFIG__PRE_CALIBRATED = 122,
    AXIS__ENCODER__CONFIG__IDX_SEARCH_SPEED = 123,
    AXIS__ENCODER__CONFIG__CPR = 124,
    AXIS__ENCODER__CONFIG__OFFSET = 125,
    AXIS__ENCODER__CONFIG__OFFSET_FLOAT = 126,
    AXIS__ENCODER__CONFIG__CALIB_RANGE = 127,
    AXIS__SENSORLESS_ESTIMATOR__ERROR = 128,
    AXIS__SENSORLESS_ESTIMATOR__PHASE = 129,
    AXIS__SENSORLESS_ESTIMATOR__PLL_POS = 130,
    AXIS__SENSORLESS_ESTIMATOR__PLL_VEL = 131,
    AXIS__SENSORLESS_ESTIMATOR__PLL_KP = 132,
    AXIS__SENSORLESS_ESTIMATOR__PLL_KI = 133,
};

template<int I>
struct endpoint_type;

template<> struct endpoint_type<VBUS_VOLTAGE> { typedef float type; };
template<> struct endpoint_type<SERIAL_NUMBER> { typedef uint64_t type; };
template<> struct endpoint_type<HW_VERSION_MAJOR> { typedef uint8_t type; };
template<> struct endpoint_type<HW_VERSION_MINOR> { typedef uint8_t type; };
template<> struct endpoint_type<HW_VERSION_VARIANT> { typedef uint8_t type; };
template<> struct endpoint_type<FW_VERSION_MAJOR> { typedef uint8_t type; };
template<> struct endpoint_type<FW_VERSION_MINOR> { typedef uint8_t type; };
template<> struct endpoint_type<FW_VERSION_REVISION> { typedef uint8_t type; };
template<> struct endpoint_type<FW_VERSION_UNRELEASED> { typedef uint8_t type; };
template<> struct endpoint_type<USER_CONFIG_LOADED> { typedef bool type; };
template<> struct endpoint_type<BRAKE_RESISTOR_ARMED> { typedef bool type; };
template<> struct endpoint_type<SYSTEM_STATS__UPTIME> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_HEAP_SPACE> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_STACK_SPACE_AXIS0> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_STACK_SPACE_AXIS1> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_STACK_SPACE_COMMS> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_STACK_SPACE_USB> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_STACK_SPACE_UART> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_STACK_SPACE_USB_IRQ> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_STACK_SPACE_STARTUP> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__USB__RX_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__USB__TX_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__USB__TX_OVERRUN_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__I2C__ADDR> { typedef uint8_t type; };
template<> struct endpoint_type<SYSTEM_STATS__I2C__ADDR_MATCH_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__I2C__RX_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__I2C__ERROR_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<CONFIG__BRAKE_RESISTANCE> { typedef float type; };
template<> struct endpoint_type<CONFIG__ENABLE_UART> { typedef bool type; };
template<> struct endpoint_type<CONFIG__ENABLE_I2C_INSTEAD_OF_CAN> { typedef bool type; };
template<> struct endpoint_type<CONFIG__DC_BUS_UNDERVOLTAGE_TRIP_LEVEL> { typedef float type; };
template<> struct endpoint_type<CONFIG__DC_BUS_OVERVOLTAGE_TRIP_LEVEL> { typedef float type; };
template<> struct endpoint_type<TEST_PROPERTY> { typedef uint32_t type; };
template<> struct endpoint_type<ADC_GPIO1> { typedef uint16_t type; };
template<> struct endpoint_type<ADC_GPIO2> { typedef uint16_t type; };
template<> struct endpoint_type<SAVE_CONFIGURATION> { typedef void type; };
template<> struct endpoint_type<ERASE_CONFIGURATION> { typedef void type; };
template<> struct endpoint_type<REBOOT> { typedef void type; };
template<> struct endpoint_type<ENTER_DFU_MODE> { typedef void type; };


// Per-axis endpoints
template<> struct endpoint_type<AXIS__ERROR> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__ENABLE_STEP_DIR> { typedef bool type; };
template<> struct endpoint_type<AXIS__CURRENT_STATE> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__REQUESTED_STATE> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__LOOP_COUNTER> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__CONFIG__STARTUP_MOTOR_CALIBRATION> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__STARTUP_ENCODER_INDEX_SEARCH> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__STARTUP_ENCODER_OFFSET_CALIBRATION> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__STARTUP_CLOSED_LOOP_CONTROL> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__STARTUP_SENSORLESS_CONTROL> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__ENABLE_STEP_DIR> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__COUNTS_PER_STEP> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__RAMP_UP_TIME> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__RAMP_UP_DISTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SPIN_UP_CURRENT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SPIN_UP_ACCELERATION> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SPIN_UP_TARGET_VEL> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__ERROR> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__ARMED_STATE> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__MOTOR__IS_CALIBRATED> { typedef bool type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_MEAS_PHB> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_MEAS_PHC> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__DC_CALIB_PHB> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__DC_CALIB_PHC> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__PHASE_CURRENT_REV_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__P_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__I_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__V_CURRENT_CONTROL_INTEGRAL_D> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__V_CURRENT_CONTROL_INTEGRAL_Q> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__IBUS> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__FINAL_V_ALPHA> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__FINAL_V_BETA> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__IQ_SETPOINT> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__IQ_MEASURED> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__MAX_ALLOWED_CURRENT> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__GATE_DRIVER__DRV_FAULT> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__TIMING_LOG_GENERAL> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__TIMING_LOG_ADC_CB_I> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__TIMING_LOG_ADC_CB_DC> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__TIMING_LOG_MEAS_R> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__TIMING_LOG_MEAS_L> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__TIMING_LOG_ENC_CALIB> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__TIMING_LOG_IDX_SEARCH> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__TIMING_LOG_FOC_VOLTAGE> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__TIMING_LOG_FOC_CURRENT> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__PRE_CALIBRATED> { typedef bool type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__POLE_PAIRS> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__CALIBRATION_CURRENT> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__RESISTANCE_CALIB_MAX_VOLTAGE> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__PHASE_INDUCTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__PHASE_RESISTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__DIRECTION> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__MOTOR_TYPE> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__CURRENT_LIM> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__POS_SETPOINT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__VEL_SETPOINT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__VEL_INTEGRATOR_CURRENT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CURRENT_SETPOINT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__CONTROL_MODE> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__POS_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__VEL_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__VEL_INTEGRATOR_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__VEL_LIMIT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__START_ANTICOGGING_CALIBRATION> { typedef void type; };
template<> struct endpoint_type<AXIS__ENCODER__ERROR> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__ENCODER__IS_READY> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__INDEX_FOUND> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__SHADOW_COUNT> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__ENCODER__COUNT_IN_CPR> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__ENCODER__OFFSET> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__ENCODER__INTERPOLATION> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__PHASE> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__POS_ESTIMATE> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__POS_CPR> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__HALL_STATE> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__ENCODER__PLL_VEL> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__PLL_KP> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__PLL_KI> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__MODE> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__USE_INDEX> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__PRE_CALIBRATED> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__IDX_SEARCH_SPEED> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__CPR> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__OFFSET> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__OFFSET_FLOAT> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__CALIB_RANGE> { typedef float type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__ERROR> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__PHASE> { typedef float type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__PLL_POS> { typedef float type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__PLL_VEL> { typedef float type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__PLL_KP> { typedef float type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__PLL_KI> { typedef float type; };


template<int I>
using endpoint_type_t = typename endpoint_type<I>::type;

}

#endif // __ODRIVE_ENDPOINTS_HPP